// Model for solving the spatial sir equation.
// maintainer: Grzegorz Gruszczynski @ggruszczynski

<?R  
	source("conf.R")
	c_header();
	source("lib/boundary.R")

  	s = PV(DensityAll$name[DensityAll$group=="s"])
	i = PV(DensityAll$name[DensityAll$group=="i"])
	r = PV(DensityAll$name[DensityAll$group=="r"])
?>


CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = <?R C(sum(s)) ?>;
  ret.y = <?R C(sum(i)) ?>;
  return ret;
}

// ------------------------ PARAVIEW OUTPUT BLOCK ------------------------
// Use this functions is only for vtk output.
// Nodes are created using streamed, post-collision DF.
// RunBoundaries are called in orded to assign the desired value at the boundary.
// It can make a difference in convergence study and nicer preview.

CudaDeviceFunction real_t getNoOfSuspected() {
	RunBoundaries();
	return (<?R C(sum(s)) ?>);
}

CudaDeviceFunction real_t getNoOfInfected() {
	RunBoundaries();
	return (<?R C(sum(i)) ?>);
}

CudaDeviceFunction real_t getNoOfRecovered() {
	RunBoundaries();
    return (<?R C(sum(r)) ?>);
}

CudaDeviceFunction real_t getFractionSuspected() {
	RunBoundaries();
	return  (<?R C(sum(s)) ?>)/populationDensity(0,0);
}

CudaDeviceFunction real_t getFractionInfected() {
	RunBoundaries();
	return  (<?R C(sum(i)) ?>)/populationDensity(0,0);
}

CudaDeviceFunction real_t getFractionRecovered() {
	RunBoundaries();
	return  (<?R C(sum(r)) ?>)/populationDensity(0,0);
}

CudaDeviceFunction real_t getFractionSum() {
	RunBoundaries();
    return (getFractionSuspected() + getFractionInfected() + getFractionRecovered());
}

CudaDeviceFunction real_t getTotalNoOfIndividuals() {
	RunBoundaries();
	return getNoOfSuspected() + getNoOfInfected() + getNoOfRecovered();;
}

// ------------------------ END OF PARAVIEW OUTPUT BLOCK ------------------------


// CudaDeviceFunction real_t getNoOfSuspected_() {
// 	return (<?R C(sum(s)) ?>);
// }

// CudaDeviceFunction real_t getNoOfInfected_() {
// 	return (<?R C(sum(i)) ?>);
// }

// CudaDeviceFunction real_t getNoOfRecovered_() {
// 	return (<?R C(sum(r)) ?>);
// }

// CudaDeviceFunction real_t getFractionSuspected_() {
// 	return  (<?R C(sum(s)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionInfected_() {
// 	return  (<?R C(sum(i)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionRecovered_() {
// 	return  (<?R C(sum(r)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionSum_() {
// 	return (getFractionSuspected_() + getFractionInfected_() + getFractionRecovered_());
// }

// CudaDeviceFunction real_t getTotalNoOfIndividuals_() {
// 	return getNoOfSuspected_() + getNoOfInfected_() + getNoOfRecovered_();;
// }
		
// CudaDeviceFunction real_t getNoOfSuspected_() {
// 	return (<?R C(sum(s)) ?>);
// }

// CudaDeviceFunction real_t getNoOfInfected_() {
//     return (<?R C(sum(i)) ?>);
// }

// CudaDeviceFunction real_t getNoOfRecovered_() {
//     return (<?R C(sum(r)) ?>);
// }

// CudaDeviceFunction real_t getFractionSuspected_() {
// 	return  (<?R C(sum(s)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionInfected_() {
// 	return  (<?R C(sum(i)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionRecovered_() {
// 	return  (<?R C(sum(r)) ?>)/populationDensity(0,0);
// }

// CudaDeviceFunction real_t getFractionSum_() {
//     return (getFractionSuspected_() + getFractionInfected_() + getFractionRecovered_());
// }

// CudaDeviceFunction real_t getTotalNoOfIndividuals_() {
// 	return getNoOfSuspected_() + getNoOfInfected_() + getNoOfRecovered_();;
// }

CudaDeviceFunction real_t getPopulationDensity() {
  return populationDensity(0,0);
}

CudaDeviceFunction real_t getOmegaTurb() {
	// TODO: why not omega_turb_multiplicator*populationDensity/GRAY_MAX; ??
	return omega_turb_multiplicator*populationDensity(0,0)/GRAY_MAX;
}

CudaDeviceFunction void PopulationDensitySmoothing(){
	real_t lap_popden = populationDensity(-1,0) + populationDensity(1,0) + populationDensity(0,-1) + populationDensity(0,1) - 4*populationDensity(0,0);
	real_t temp = population_smoothing * population_smoothing * lap_popden;
	populationDensity = populationDensity(0,0) + temp;
}

CudaDeviceFunction void Init() { 
	populationDensity = Init_PopulationDensity;
	if ((NodeType & NODE_IMAGE) == NODE_ImageReader){
		// populationDensity = (real_t)gray_scale_intensity*Init_PopulationDensity;
		populationDensity = (real_t)gray_scale_intensity;
	}
	
	Init_eq(populationDensity);
}

CudaDeviceFunction void Init_eq(real_t rho)
{	
	real_t Init_S = Init_S_Fraction * rho;
	real_t Init_I = Init_I_Fraction * rho;
	real_t Init_R = Init_R_Fraction * rho;
	
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	real_t Sigma2 = 0.333333333333333*stability_enhancement/rho;
	//--- processing s ---
	
	//equilibrium
	real_t s_eq_000 = Init_S;
	real_t s_eq_100 = 0;
	real_t s_eq_010 = 0;
	real_t s_eq_200 = Init_S*Sigma2;
	real_t s_eq_020 = Init_S*Sigma2;
	real_t s_eq_110 = 0;
	real_t s_eq_210 = 0;
	real_t s_eq_120 = 0;
	real_t s_eq_220 = Init_S*Sigma2*Sigma2;
	//back to density-probability functions
	s000 = s_eq_000 - s_eq_020 - s_eq_200 + s_eq_220;
	s100 = 1/2.*s_eq_100 - 1/2.*s_eq_120 + 1/2.*s_eq_200 - 1/2.*s_eq_220;
	s200 = -1/2.*s_eq_100 + 1/2.*s_eq_120 + 1/2.*s_eq_200 - 1/2.*s_eq_220;
	s010 = 1/2.*s_eq_010 + 1/2.*s_eq_020 - 1/2.*s_eq_210 - 1/2.*s_eq_220;
	s110 = 1/4.*s_eq_110 + 1/4.*s_eq_120 + 1/4.*s_eq_210 + 1/4.*s_eq_220;
	s210 = -1/4.*s_eq_110 - 1/4.*s_eq_120 + 1/4.*s_eq_210 + 1/4.*s_eq_220;
	s020 = -1/2.*s_eq_010 + 1/2.*s_eq_020 + 1/2.*s_eq_210 - 1/2.*s_eq_220;
	s120 = -1/4.*s_eq_110 + 1/4.*s_eq_120 - 1/4.*s_eq_210 + 1/4.*s_eq_220;
	s220 = 1/4.*s_eq_110 - 1/4.*s_eq_120 - 1/4.*s_eq_210 + 1/4.*s_eq_220;
	//--- processing i ---
	//equilibrium
	real_t i_eq_000 = Init_I;
	real_t i_eq_100 = 0;
	real_t i_eq_010 = 0;
	real_t i_eq_200 = Init_I*Sigma2;
	real_t i_eq_020 = Init_I*Sigma2;
	real_t i_eq_110 = 0;
	real_t i_eq_210 = 0;
	real_t i_eq_120 = 0;
	real_t i_eq_220 = Init_I*Sigma2*Sigma2;
	//back to density-probability functions
	i000 = i_eq_000 - i_eq_020 - i_eq_200 + i_eq_220;
	i100 = 1/2.*i_eq_100 - 1/2.*i_eq_120 + 1/2.*i_eq_200 - 1/2.*i_eq_220;
	i200 = -1/2.*i_eq_100 + 1/2.*i_eq_120 + 1/2.*i_eq_200 - 1/2.*i_eq_220;
	i010 = 1/2.*i_eq_010 + 1/2.*i_eq_020 - 1/2.*i_eq_210 - 1/2.*i_eq_220;
	i110 = 1/4.*i_eq_110 + 1/4.*i_eq_120 + 1/4.*i_eq_210 + 1/4.*i_eq_220;
	i210 = -1/4.*i_eq_110 - 1/4.*i_eq_120 + 1/4.*i_eq_210 + 1/4.*i_eq_220;
	i020 = -1/2.*i_eq_010 + 1/2.*i_eq_020 + 1/2.*i_eq_210 - 1/2.*i_eq_220;
	i120 = -1/4.*i_eq_110 + 1/4.*i_eq_120 - 1/4.*i_eq_210 + 1/4.*i_eq_220;
	i220 = 1/4.*i_eq_110 - 1/4.*i_eq_120 - 1/4.*i_eq_210 + 1/4.*i_eq_220;
	//--- processing r ---
	//equilibrium
	real_t r_eq_000 = Init_R;
	real_t r_eq_100 = 0;
	real_t r_eq_010 = 0;
	real_t r_eq_200 = Init_R*Sigma2;
	real_t r_eq_020 = Init_R*Sigma2;
	real_t r_eq_110 = 0;
	real_t r_eq_210 = 0;
	real_t r_eq_120 = 0;
	real_t r_eq_220 = Init_R*Sigma2*Sigma2;
	//back to density-probability functions
	r000 = r_eq_000 - r_eq_020 - r_eq_200 + r_eq_220;
	r100 = 1/2.*r_eq_100 - 1/2.*r_eq_120 + 1/2.*r_eq_200 - 1/2.*r_eq_220;
	r200 = -1/2.*r_eq_100 + 1/2.*r_eq_120 + 1/2.*r_eq_200 - 1/2.*r_eq_220;
	r010 = 1/2.*r_eq_010 + 1/2.*r_eq_020 - 1/2.*r_eq_210 - 1/2.*r_eq_220;
	r110 = 1/4.*r_eq_110 + 1/4.*r_eq_120 + 1/4.*r_eq_210 + 1/4.*r_eq_220;
	r210 = -1/4.*r_eq_110 - 1/4.*r_eq_120 + 1/4.*r_eq_210 + 1/4.*r_eq_220;
	r020 = -1/2.*r_eq_010 + 1/2.*r_eq_020 + 1/2.*r_eq_210 - 1/2.*r_eq_220;
	r120 = -1/4.*r_eq_110 + 1/4.*r_eq_120 - 1/4.*r_eq_210 + 1/4.*r_eq_220;
	r220 = 1/4.*r_eq_110 - 1/4.*r_eq_120 - 1/4.*r_eq_210 + 1/4.*r_eq_220;
}

CudaDeviceFunction void RunBoundaries()
{	
	populationDensity = populationDensity(0,0);
	
	switch (NodeType & NODE_BOUNDARY) {
		case NODE_Wall:
			BounceBack();
			break;
		case NODE_DirichletEQ:  		
			// equilibrium scheme for BC - don't care and impose rho*Teq
			// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
			// by T. Kr√ºger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
			Init_eq(populationDensity); 
			break; 
	}
}

CudaDeviceFunction void Run() {
	if ((NodeType & NODE_ADDITIONALS) == NODE_Smoothing){
		PopulationDensitySmoothing();
		Init_eq(populationDensity);
	}
	else{
		real_t omega_ade = 1.0/(3*diffusivity/stability_enhancement+0.5);
		// if ((NodeType & NODE_BOUNDARY) != 0) omega_ade = 1.0/(3*diffusivity_buffer+0.5);

		real_t omega_turb = getOmegaTurb();
		omega_ade += omega_turb;

		RunBoundaries(); // keep in mind that populationDensity = populationDensity(0,0); needs to be called before collision
		switch (NodeType & NODE_COLLISION) {    
			case NODE_MRT:
				relax_and_collide_SIR_M(populationDensity, omega_ade);
				break;
			case NODE_CROSSMRT:
				relax_and_collide_cross_SIR_M(populationDensity, omega_ade);
				break;
		}

		AddToNoOfSuspected(<?R C(sum(s)) ?>);  
		AddToNoOfInfected(<?R C(sum(s)) ?>);  
		AddToNoOfRecovered(<?R C(sum(s)) ?>);  
	}
 }

 CudaDeviceFunction void BounceBack()
 {
	<?R 
		FullBounceBack()
   	?> 
 }



 
CudaDeviceFunction void relax_and_collide_cross_SIR_M(real_t rho, real_t omega_r) 
{
	real_t Sigma2 = 0.333333333333333*stability_enhancement/rho;
	real_t S = s000 + s010 + s020 + s100 + s110 + s120 + s200 + s210 + s220;
	real_t I = i000 + i010 + i020 + i100 + i110 + i120 + i200 + i210 + i220;
	real_t R = r000 + r010 + r020 + r100 + r110 + r120 + r200 + r210 + r220;
	real_t s = S/rho;
	real_t i = I/rho;
	real_t r = R/rho;

	real_t cross_difussivity = 1/8.*S*infectious_radius*infectious_radius*sir_beta;
	real_t omega_cross = 1.0/(3*cross_difussivity/stability_enhancement+0.5);

	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	real_t temp000;
	real_t temp100;
	real_t temp010;
	real_t temp200;
	real_t temp020;
	real_t temp110;
	real_t temp210;
	real_t temp120;
	real_t temp220;
	 //--- processing i ---
	temp000 = i000;
	temp100 = i100;
	temp010 = i010;
	temp200 = i200;
	temp020 = i020;
	temp110 = i110;
	temp210 = i210;
	temp120 = i120;
	temp220 = i220;
	//raw moments from density-probability functions
	i000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	i100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	i010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	i200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	i020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	i110 = temp110 - temp120 - temp210 + temp220;
	i210 = temp110 - temp120 + temp210 - temp220;
	i120 = temp110 + temp120 - temp210 - temp220;
	i220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t cross_star_000 = omega_cross*(I - i000);
	real_t cross_star_100 = -i100*omega_cross;
	real_t cross_star_010 = -i010*omega_cross;
	real_t cross_star_200 = omega_cross*(I*Sigma2 - i200);
	real_t cross_star_020 = omega_cross*(I*Sigma2 - i020);
	real_t cross_star_110 = -i110*omega_cross;
	real_t cross_star_210 = -i210*omega_cross;
	real_t cross_star_120 = -i120*omega_cross;
	real_t cross_star_220 = omega_cross*(I*Sigma2*Sigma2 - i220);
	real_t i_star_000 = cross_star_000 - i*s*sir_beta + i000;
	real_t i_star_100 = cross_star_100 + i100;
	real_t i_star_010 = cross_star_010 + i010;
	real_t i_star_200 = -Sigma2*i*s*sir_beta + cross_star_200 + i200;
	real_t i_star_020 = -Sigma2*i*s*sir_beta + cross_star_020 + i020;
	real_t i_star_110 = cross_star_110 + i110;
	real_t i_star_210 = cross_star_210 + i210;
	real_t i_star_120 = cross_star_120 + i120;
	real_t i_star_220 = -Sigma2*Sigma2*i*s*sir_beta + cross_star_220 + i220;
	//back to density-probability functions
	i000 = i_star_000 - i_star_020 - i_star_200 + i_star_220;
	i100 = 1/2.*i_star_100 - 1/2.*i_star_120 + 1/2.*i_star_200 - 1/2.*i_star_220;
	i200 = -1/2.*i_star_100 + 1/2.*i_star_120 + 1/2.*i_star_200 - 1/2.*i_star_220;
	i010 = 1/2.*i_star_010 + 1/2.*i_star_020 - 1/2.*i_star_210 - 1/2.*i_star_220;
	i110 = 1/4.*i_star_110 + 1/4.*i_star_120 + 1/4.*i_star_210 + 1/4.*i_star_220;
	i210 = -1/4.*i_star_110 - 1/4.*i_star_120 + 1/4.*i_star_210 + 1/4.*i_star_220;
	i020 = -1/2.*i_star_010 + 1/2.*i_star_020 + 1/2.*i_star_210 - 1/2.*i_star_220;
	i120 = -1/4.*i_star_110 + 1/4.*i_star_120 - 1/4.*i_star_210 + 1/4.*i_star_220;
	i220 = 1/4.*i_star_110 - 1/4.*i_star_120 - 1/4.*i_star_210 + 1/4.*i_star_220;
	 //--- processing s ---
	temp000 = s000;
	temp100 = s100;
	temp010 = s010;
	temp200 = s200;
	temp020 = s020;
	temp110 = s110;
	temp210 = s210;
	temp120 = s120;
	temp220 = s220;
	//raw moments from density-probability functions
	s000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	s100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	s010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	s200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	s020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	s110 = temp110 - temp120 - temp210 + temp220;
	s210 = temp110 - temp120 + temp210 - temp220;
	s120 = temp110 + temp120 - temp210 - temp220;
	s220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t s_star_000 = -cross_star_000 + i*s*sir_beta - i*sir_gamma + s000;
	real_t s_star_100 = -cross_star_100 + s100;
	real_t s_star_010 = -cross_star_010 + s010;
	real_t s_star_200 = Sigma2*i*(s*sir_beta - sir_gamma) - cross_star_200 + s200;
	real_t s_star_020 = Sigma2*i*(s*sir_beta - sir_gamma) - cross_star_020 + s020;
	real_t s_star_110 = -cross_star_110 + s110;
	real_t s_star_210 = -cross_star_210 + s210;
	real_t s_star_120 = -cross_star_120 + s120;
	real_t s_star_220 = Sigma2*Sigma2*i*(s*sir_beta - sir_gamma) - cross_star_220 + s220;
	//back to density-probability functions
	s000 = s_star_000 - s_star_020 - s_star_200 + s_star_220;
	s100 = 1/2.*s_star_100 - 1/2.*s_star_120 + 1/2.*s_star_200 - 1/2.*s_star_220;
	s200 = -1/2.*s_star_100 + 1/2.*s_star_120 + 1/2.*s_star_200 - 1/2.*s_star_220;
	s010 = 1/2.*s_star_010 + 1/2.*s_star_020 - 1/2.*s_star_210 - 1/2.*s_star_220;
	s110 = 1/4.*s_star_110 + 1/4.*s_star_120 + 1/4.*s_star_210 + 1/4.*s_star_220;
	s210 = -1/4.*s_star_110 - 1/4.*s_star_120 + 1/4.*s_star_210 + 1/4.*s_star_220;
	s020 = -1/2.*s_star_010 + 1/2.*s_star_020 + 1/2.*s_star_210 - 1/2.*s_star_220;
	s120 = -1/4.*s_star_110 + 1/4.*s_star_120 - 1/4.*s_star_210 + 1/4.*s_star_220;
	s220 = 1/4.*s_star_110 - 1/4.*s_star_120 - 1/4.*s_star_210 + 1/4.*s_star_220;
	 //--- processing r ---
	temp000 = r000;
	temp100 = r100;
	temp010 = r010;
	temp200 = r200;
	temp020 = r020;
	temp110 = r110;
	temp210 = r210;
	temp120 = r120;
	temp220 = r220;
	//raw moments from density-probability functions
	r000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	r100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	r010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	r200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	r020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	r110 = temp110 - temp120 - temp210 + temp220;
	r210 = temp110 - temp120 + temp210 - temp220;
	r120 = temp110 + temp120 - temp210 - temp220;
	r220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t r_star_000 = R + i*sir_gamma;
	real_t r_star_100 = -r100*(omega_r - 1.);
	real_t r_star_010 = -r010*(omega_r - 1.);
	real_t r_star_200 = Sigma2*(R + i*sir_gamma);
	real_t r_star_020 = Sigma2*(R + i*sir_gamma);
	real_t r_star_110 = 0;
	real_t r_star_210 = -r210*(omega_r - 1.);
	real_t r_star_120 = -r120*(omega_r - 1.);
	real_t r_star_220 = Sigma2*Sigma2*(R + i*sir_gamma);
	//back to density-probability functions
	r000 = r_star_000 - r_star_020 - r_star_200 + r_star_220;
	r100 = 1/2.*r_star_100 - 1/2.*r_star_120 + 1/2.*r_star_200 - 1/2.*r_star_220;
	r200 = -1/2.*r_star_100 + 1/2.*r_star_120 + 1/2.*r_star_200 - 1/2.*r_star_220;
	r010 = 1/2.*r_star_010 + 1/2.*r_star_020 - 1/2.*r_star_210 - 1/2.*r_star_220;
	r110 = 1/4.*r_star_110 + 1/4.*r_star_120 + 1/4.*r_star_210 + 1/4.*r_star_220;
	r210 = -1/4.*r_star_110 - 1/4.*r_star_120 + 1/4.*r_star_210 + 1/4.*r_star_220;
	r020 = -1/2.*r_star_010 + 1/2.*r_star_020 + 1/2.*r_star_210 - 1/2.*r_star_220;
	r120 = -1/4.*r_star_110 + 1/4.*r_star_120 - 1/4.*r_star_210 + 1/4.*r_star_220;
	r220 = 1/4.*r_star_110 - 1/4.*r_star_120 - 1/4.*r_star_210 + 1/4.*r_star_220;
}

CudaDeviceFunction void relax_and_collide_SIR_M(real_t rho, real_t omega_ade) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	real_t Sigma2 = 0.333333333333333*stability_enhancement/rho;
	real_t S = s000 + s010 + s020 + s100 + s110 + s120 + s200 + s210 + s220;
	real_t I = i000 + i010 + i020 + i100 + i110 + i120 + i200 + i210 + i220;
	real_t R = r000 + r010 + r020 + r100 + r110 + r120 + r200 + r210 + r220;
	real_t s = S/rho;
	real_t i = I/rho;
	real_t r = R/rho;
	real_t temp000;
	real_t temp100;
	real_t temp010;
	real_t temp200;
	real_t temp020;
	real_t temp110;
	real_t temp210;
	real_t temp120;
	real_t temp220;
	 //--- processing s ---
	temp000 = s000;
	temp100 = s100;
	temp010 = s010;
	temp200 = s200;
	temp020 = s020;
	temp110 = s110;
	temp210 = s210;
	temp120 = s120;
	temp220 = s220;
	//raw moments from density-probability functions
	s000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	s100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	s010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	s200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	s020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	s110 = temp110 - temp120 - temp210 + temp220;
	s210 = temp110 - temp120 + temp210 - temp220;
	s120 = temp110 + temp120 - temp210 - temp220;
	s220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t s_star_000 = S - i*s*sir_beta;
	real_t s_star_100 = -s100*(omega_ade - 1.);
	real_t s_star_010 = -s010*(omega_ade - 1.);
	real_t s_star_200 = Sigma2*(S - i*s*sir_beta);
	real_t s_star_020 = Sigma2*(S - i*s*sir_beta);
	real_t s_star_110 = 0;
	real_t s_star_210 = -s210*(omega_ade - 1.);
	real_t s_star_120 = -s120*(omega_ade - 1.);
	real_t s_star_220 = Sigma2*Sigma2*(S - i*s*sir_beta);
	//back to density-probability functions
	s000 = s_star_000 - s_star_020 - s_star_200 + s_star_220;
	s100 = 1/2.*s_star_100 - 1/2.*s_star_120 + 1/2.*s_star_200 - 1/2.*s_star_220;
	s200 = -1/2.*s_star_100 + 1/2.*s_star_120 + 1/2.*s_star_200 - 1/2.*s_star_220;
	s010 = 1/2.*s_star_010 + 1/2.*s_star_020 - 1/2.*s_star_210 - 1/2.*s_star_220;
	s110 = 1/4.*s_star_110 + 1/4.*s_star_120 + 1/4.*s_star_210 + 1/4.*s_star_220;
	s210 = -1/4.*s_star_110 - 1/4.*s_star_120 + 1/4.*s_star_210 + 1/4.*s_star_220;
	s020 = -1/2.*s_star_010 + 1/2.*s_star_020 + 1/2.*s_star_210 - 1/2.*s_star_220;
	s120 = -1/4.*s_star_110 + 1/4.*s_star_120 - 1/4.*s_star_210 + 1/4.*s_star_220;
	s220 = 1/4.*s_star_110 - 1/4.*s_star_120 - 1/4.*s_star_210 + 1/4.*s_star_220;
	 //--- processing i ---
	temp000 = i000;
	temp100 = i100;
	temp010 = i010;
	temp200 = i200;
	temp020 = i020;
	temp110 = i110;
	temp210 = i210;
	temp120 = i120;
	temp220 = i220;
	//raw moments from density-probability functions
	i000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	i100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	i010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	i200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	i020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	i110 = temp110 - temp120 - temp210 + temp220;
	i210 = temp110 - temp120 + temp210 - temp220;
	i120 = temp110 + temp120 - temp210 - temp220;
	i220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t i_star_000 = I + i*s*sir_beta - i*sir_gamma;
	real_t i_star_100 = -i100*(omega_ade - 1.);
	real_t i_star_010 = -i010*(omega_ade - 1.);
	real_t i_star_200 = Sigma2*(I + i*(s*sir_beta - sir_gamma));
	real_t i_star_020 = Sigma2*(I + i*(s*sir_beta - sir_gamma));
	real_t i_star_110 = 0;
	real_t i_star_210 = -i210*(omega_ade - 1.);
	real_t i_star_120 = -i120*(omega_ade - 1.);
	real_t i_star_220 = Sigma2*Sigma2*(I + i*(s*sir_beta - sir_gamma));
	//back to density-probability functions
	i000 = i_star_000 - i_star_020 - i_star_200 + i_star_220;
	i100 = 1/2.*i_star_100 - 1/2.*i_star_120 + 1/2.*i_star_200 - 1/2.*i_star_220;
	i200 = -1/2.*i_star_100 + 1/2.*i_star_120 + 1/2.*i_star_200 - 1/2.*i_star_220;
	i010 = 1/2.*i_star_010 + 1/2.*i_star_020 - 1/2.*i_star_210 - 1/2.*i_star_220;
	i110 = 1/4.*i_star_110 + 1/4.*i_star_120 + 1/4.*i_star_210 + 1/4.*i_star_220;
	i210 = -1/4.*i_star_110 - 1/4.*i_star_120 + 1/4.*i_star_210 + 1/4.*i_star_220;
	i020 = -1/2.*i_star_010 + 1/2.*i_star_020 + 1/2.*i_star_210 - 1/2.*i_star_220;
	i120 = -1/4.*i_star_110 + 1/4.*i_star_120 - 1/4.*i_star_210 + 1/4.*i_star_220;
	i220 = 1/4.*i_star_110 - 1/4.*i_star_120 - 1/4.*i_star_210 + 1/4.*i_star_220;
	 //--- processing r ---
	temp000 = r000;
	temp100 = r100;
	temp010 = r010;
	temp200 = r200;
	temp020 = r020;
	temp110 = r110;
	temp210 = r210;
	temp120 = r120;
	temp220 = r220;
	//raw moments from density-probability functions
	r000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	r100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	r010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	r200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	r020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	r110 = temp110 - temp120 - temp210 + temp220;
	r210 = temp110 - temp120 + temp210 - temp220;
	r120 = temp110 + temp120 - temp210 - temp220;
	r220 = temp110 + temp120 + temp210 + temp220;
	//collide
	real_t r_star_000 = R + i*sir_gamma;
	real_t r_star_100 = -r100*(omega_ade - 1.);
	real_t r_star_010 = -r010*(omega_ade - 1.);
	real_t r_star_200 = Sigma2*(R + i*sir_gamma);
	real_t r_star_020 = Sigma2*(R + i*sir_gamma);
	real_t r_star_110 = 0;
	real_t r_star_210 = -r210*(omega_ade - 1.);
	real_t r_star_120 = -r120*(omega_ade - 1.);
	real_t r_star_220 = Sigma2*Sigma2*(R + i*sir_gamma);
	//back to density-probability functions
	r000 = r_star_000 - r_star_020 - r_star_200 + r_star_220;
	r100 = 1/2.*r_star_100 - 1/2.*r_star_120 + 1/2.*r_star_200 - 1/2.*r_star_220;
	r200 = -1/2.*r_star_100 + 1/2.*r_star_120 + 1/2.*r_star_200 - 1/2.*r_star_220;
	r010 = 1/2.*r_star_010 + 1/2.*r_star_020 - 1/2.*r_star_210 - 1/2.*r_star_220;
	r110 = 1/4.*r_star_110 + 1/4.*r_star_120 + 1/4.*r_star_210 + 1/4.*r_star_220;
	r210 = -1/4.*r_star_110 - 1/4.*r_star_120 + 1/4.*r_star_210 + 1/4.*r_star_220;
	r020 = -1/2.*r_star_010 + 1/2.*r_star_020 + 1/2.*r_star_210 - 1/2.*r_star_220;
	r120 = -1/4.*r_star_110 + 1/4.*r_star_120 - 1/4.*r_star_210 + 1/4.*r_star_220;
	r220 = 1/4.*r_star_110 - 1/4.*r_star_120 - 1/4.*r_star_210 + 1/4.*r_star_220;
}
