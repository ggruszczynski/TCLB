<?R
	source("conf.R") 
	source("lib/boundary.R")
	c_header();

# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	h = PV(DensityAll$name[DensityAll$group=="h"])
	rho =  PV("rho")
	u = PV(c("ux","uy"))
	rhoT = PV("rhoT")

# Extracting velocity set
	U = d2q9

?>

CudaDeviceFunction real_t getm00_F(){
	real_t m00_F = <?R C(sum(f)) ?>;
	return m00_F/material_density; // TODO: or return m00_F; 
}

CudaDeviceFunction real_t getcp(){
	return cp;
}

CudaDeviceFunction real_t getmaterial_density(){
	return material_density;
}

CudaDeviceFunction real_t getconductivity(){
	return conductivity;
}

CudaDeviceFunction real_t getRho(){
	real_t m00_F = <?R C(sum(f)) ?>;
	return m00_F; // TODO: return m00_F* material_density; 
}

CudaDeviceFunction real_t getT(){
	real_t rho = getRho();
	real_t m00_H = <?R C(sum(h)) ?>;
	return m00_H/(rho*cp);
}


CudaDeviceFunction real_t getH(){
	return <?R C(sum(h)) ?>;
}

CudaDeviceFunction vector_t getRawU(){
	real_t rho = getRho();
	vector_t u;
  <?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= rho;
	u.y /= rho;
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t getU()
{
	real_t localTemperature = getT();
	vector_t u = getRawU();
	real_t rho = getRho();
	vector_t Force = getForce(localTemperature, rho);
	u.x += Force.x/(2*rho);
	u.y += Force.y/(2*rho);
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t get_fDarcyStoper(real_t rho, vector_t u)
{
	vector_t fDarcy;
	fDarcy.x = -2*rho*(u.x);
	fDarcy.y = -2*rho*(u.y);
	fDarcy.z = 0;
	return fDarcy;
}

CudaDeviceFunction float2 Color() {
	float2 ret;
	//vector_t u = getRawU();

	ret.x = getT();
	ret.y = ret.x;

	// ret.y = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
	return ret;
}


CudaDeviceFunction void EVelocity()
{}

CudaDeviceFunction void WPressure()
{}

CudaDeviceFunction void WVelocity()
{}

CudaDeviceFunction void EPressure()
{}

CudaDeviceFunction void HeatNeumannForFluid()
{
	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();
	// TCLB is smart enough to distiguish values prescribed it batch.xml like
	// InitTemperature-dirichlet_region="123"
	// InitTemperature-neumann_heater_region="456"
	real_t H = rho*cp*T;  
	real_t h_source[9];
	SetEquilibriumHeat(h_source, H, rho, u); 
	for (int i = 0; i < 9; i++) {
		h[i] += h_source[i];}
}

CudaDeviceFunction void HeatDirichletEquilibriumScheme()
{
	// equilibrium scheme for BC - don't care and impose rho*Teq
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();
	
	real_t H = rho*cp*T;
	real_t h_eq[9];
	SetEquilibriumHeat(h_eq, H, rho, u); 

	for (int i = 0; i < 9; i++) {
		h[i] = h_eq[i];
	}
}

CudaDeviceFunction void HeatDirichletAntiBounceBackScheme()
{
	// Anti-Bounce-Back Scheme
	// see chapter 8.5.2.1, eq 8.53, p318 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
	real_t T = InitTemperature;
	real_t rho = getRho();
	vector_t u = getU();

	real_t H = rho*cp*T;
	real_t h_eq[9];
	SetEquilibriumHeat(h_eq, H, rho, u);

	for (int i = 0; i < 9; i++) {
		h[i] = -h[i] + 2*h_eq[i]; // ABB: reverse to obtain zero temperature: h[i] = -h[i]
	}
}


CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
		case NODE_EVelocity:
			EVelocity();
			break;
		case NODE_WPressure:
			WPressure();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;
		case NODE_EPressure:
			EPressure();
			break;
		case NODE_Wall:
			BounceBack();
			break;
	}
	
    switch (NodeType & NODE_COLLISION) {
		case NODE_CM:
			CollisionCM();
			break;
	}

	if ((NodeType & NODE_ADDITIONALS_HEAT) == NODE_HeaterDirichletTemperature) {
		HeatDirichletEquilibriumScheme();
		// alternatively:
		// HeatDirichletAntiBounceBackScheme();
	}

	if ((NodeType & NODE_ADDITIONALS_HEAT) == NODE_HeaterNeumannHeatFlux) {
		HeatNeumannForFluid();
	}	
}



CudaDeviceFunction void BounceBack()
{
	<?R 
		FullBounceBack() 
	?>
}

CudaDeviceFunction void SetEquilibriumFluid(real_t f_in[9], real_t rho, vector_t u) 
{
	// #TODO: with Force?
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t temp[9];

	//equilibrium in central moments space
	f_in[0] = rho;
	f_in[1] = 0;
	f_in[2] = 0;
	f_in[3] = 1/3.*rho;
	f_in[4] = 1/3.*rho;
	f_in[5] = 0;
	f_in[6] = 0;
	f_in[7] = 0;
	f_in[8] = 1/9.*rho;

	//back to raw moments
	temp[0] = f_in[0];
	temp[1] = u.x*f_in[0] + f_in[1];
	temp[2] = u.y*f_in[0] + f_in[2];
	temp[3] = ux2*f_in[0] + 2.*u.x*f_in[1] + f_in[3];
	temp[4] = uy2*f_in[0] + 2.*u.y*f_in[2] + f_in[4];
	temp[5] = uxuy*f_in[0] + u.x*f_in[2] + u.y*f_in[1] + f_in[5];
	temp[6] = ux2*u.y*f_in[0] + ux2*f_in[2] + 2.*uxuy*f_in[1] + 2.*u.x*f_in[5] + u.y*f_in[3] + f_in[6];
	temp[7] = u.x*uy2*f_in[0] + 2.*uxuy*f_in[2] + u.x*f_in[4] + uy2*f_in[1] + 2.*u.y*f_in[5] + f_in[7];
	temp[8] = ux2*uy2*f_in[0] + 2.*ux2*u.y*f_in[2] + ux2*f_in[4] + 2.*u.x*uy2*f_in[1] + 4.*uxuy*f_in[5] + 2.*u.x*f_in[7] + uy2*f_in[3] + 2.*u.y*f_in[6] + f_in[8];

	//back to density-probability functions
	f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	f_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	f_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	f_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	f_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	f_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	f_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	f_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	f_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];

}

CudaDeviceFunction void SetEquilibriumHeat(real_t h_in[9], real_t H, real_t rho, vector_t u) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t temp[9];
	real_t Sigma2 = (h_stability_enhancement*1./3.)/(cp*rho);

	//equilibrium in central moments space
	h_in[0] = H;
	h_in[1] = 0;
	h_in[2] = 0;
	h_in[3] = H*Sigma2;
	h_in[4] = H*Sigma2;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 0;
	h_in[8] = H*Sigma2*Sigma2;

	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = u.x*h_in[0] + h_in[1];
	temp[2] = u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] + 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] + 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] + u.x*h_in[2] + u.y*h_in[1] + h_in[5];
	temp[6] = ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] + 2.*u.x*h_in[5] + u.y*h_in[3] + h_in[6];
	temp[7] = u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] + u.x*h_in[4] + uy2*h_in[1] + 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] + 2.*ux2*u.y*h_in[2] + ux2*h_in[4] + 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] + 2.*u.x*h_in[7] + uy2*h_in[3] + 2.*u.y*h_in[6] + h_in[8];

	//back to density-probability functions
	h_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	h_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	h_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	h_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	h_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	h_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	h_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}


CudaDeviceFunction void Init() {
	real_t rho = 1.0*material_density;
	real_t H = rho*cp*InitTemperature;
	vector_t u; u.x = VelocityX; u.y = 0; u.z = 0;

	SetEquilibriumFluid(f,rho,u);
	SetEquilibriumHeat(h,H,rho,u);
}

CudaDeviceFunction void relax_and_collide_hydro_with_F(real_t x_in[9], real_t rho, real_t omega_nu, vector_t u, vector_t F) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	real_t m00 = x_in[0] + x_in[1] + x_in[2] + x_in[3] + x_in[4] + x_in[5] + x_in[6] + x_in[7] + x_in[8];
	real_t temp[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = x_in[i];}
	//raw moments from density-probability functions
	x_in[0] = temp[0] + temp[1] + temp[2] + temp[3] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	x_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	x_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	x_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	x_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	x_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	x_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
	//central moments from raw moments
	temp[0] = x_in[0];
	temp[1] = -u.x*x_in[0] + x_in[1];
	temp[2] = -u.y*x_in[0] + x_in[2];
	temp[3] = ux2*x_in[0] - 2.*u.x*x_in[1] + x_in[3];
	temp[4] = uy2*x_in[0] - 2.*u.y*x_in[2] + x_in[4];
	temp[5] = uxuy*x_in[0] - u.x*x_in[2] - u.y*x_in[1] + x_in[5];
	temp[6] = -ux2*u.y*x_in[0] + ux2*x_in[2] + 2.*uxuy*x_in[1] - 2.*u.x*x_in[5] - u.y*x_in[3] + x_in[6];
	temp[7] = -u.x*uy2*x_in[0] + 2.*uxuy*x_in[2] - u.x*x_in[4] + uy2*x_in[1] - 2.*u.y*x_in[5] + x_in[7];
	temp[8] = ux2*uy2*x_in[0] - 2.*ux2*u.y*x_in[2] + ux2*x_in[4] - 2.*u.x*uy2*x_in[1] + 4.*uxuy*x_in[5] - 2.*u.x*x_in[7] + uy2*x_in[3] - 2.*u.y*x_in[6] + x_in[8];
	//collision in central moments space
	//collide
	x_in[0] = m00;
	x_in[1] = 1/2.*F.x/rho;
	x_in[2] = 1/2.*F.y/rho;
	x_in[3] = 1/3.*m00*omega_bulk - 1/2.*omega_bulk*temp[3] - 1/2.*omega_bulk*temp[4] - 1/2.*omega_nu*temp[3] + 1/2.*omega_nu*temp[4] + temp[3];
	x_in[4] = 1/3.*m00*omega_bulk - 1/2.*omega_bulk*temp[3] - 1/2.*omega_bulk*temp[4] + 1/2.*omega_nu*temp[3] - 1/2.*omega_nu*temp[4] + temp[4];
	x_in[5] = -temp[5]*(omega_nu - 1.);
	x_in[6] = 1/6.*F.y/rho;
	x_in[7] = 1/6.*F.x/rho;
	x_in[8] = 1/9.*m00;
	//back to raw moments
	temp[0] = x_in[0];
	temp[1] = u.x*x_in[0] + x_in[1];
	temp[2] = u.y*x_in[0] + x_in[2];
	temp[3] = ux2*x_in[0] + 2.*u.x*x_in[1] + x_in[3];
	temp[4] = uy2*x_in[0] + 2.*u.y*x_in[2] + x_in[4];
	temp[5] = uxuy*x_in[0] + u.x*x_in[2] + u.y*x_in[1] + x_in[5];
	temp[6] = ux2*u.y*x_in[0] + ux2*x_in[2] + 2.*uxuy*x_in[1] + 2.*u.x*x_in[5] + u.y*x_in[3] + x_in[6];
	temp[7] = u.x*uy2*x_in[0] + 2.*uxuy*x_in[2] + u.x*x_in[4] + uy2*x_in[1] + 2.*u.y*x_in[5] + x_in[7];
	temp[8] = ux2*uy2*x_in[0] + 2.*ux2*u.y*x_in[2] + ux2*x_in[4] + 2.*u.x*uy2*x_in[1] + 4.*uxuy*x_in[5] + 2.*u.x*x_in[7] + uy2*x_in[3] + 2.*u.y*x_in[6] + x_in[8];
	//back to density-probability functions
	x_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	x_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	x_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	x_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	x_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	x_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	x_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	x_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	x_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}

CudaDeviceFunction void relax_and_collide_ADE(real_t h_in[9], real_t rho, real_t omega_ade, vector_t u) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE: relax and collide ===
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;


	real_t H = h_in[0] + h_in[1] + h_in[2] + h_in[3] + h_in[4] + h_in[5] + h_in[6] + h_in[7] + h_in[8];

	real_t Sigma2 = (h_stability_enhancement*1./3.)/(cp*rho);

	real_t temp[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = h_in[i];}
	//raw moments from density-probability functions
	h_in[0] = temp[0] + temp[1] + temp[2] + temp[3] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	h_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	h_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	h_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	h_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	h_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	h_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
	//central moments from raw moments
	temp[0] = h_in[0];
	temp[1] = -u.x*h_in[0] + h_in[1];
	temp[2] = -u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] - 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] - 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] - u.x*h_in[2] - u.y*h_in[1] + h_in[5];
	temp[6] = -ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] - 2.*u.x*h_in[5] - u.y*h_in[3] + h_in[6];
	temp[7] = -u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] - u.x*h_in[4] + uy2*h_in[1] - 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] - 2.*ux2*u.y*h_in[2] + ux2*h_in[4] - 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] - 2.*u.x*h_in[7] + uy2*h_in[3] - 2.*u.y*h_in[6] + h_in[8];
	//collision in central moments space
	//collide
	h_in[0] = H;
	h_in[1] = -temp[1]*(omega_ade - 1.);
	h_in[2] = -temp[2]*(omega_ade - 1.);
	h_in[3] = Sigma2*H;
	h_in[4] = Sigma2*H;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 0;
	h_in[8] = Sigma2*Sigma2*H;
	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = u.x*h_in[0] + h_in[1];
	temp[2] = u.y*h_in[0] + h_in[2];
	temp[3] = ux2*h_in[0] + 2.*u.x*h_in[1] + h_in[3];
	temp[4] = uy2*h_in[0] + 2.*u.y*h_in[2] + h_in[4];
	temp[5] = uxuy*h_in[0] + u.x*h_in[2] + u.y*h_in[1] + h_in[5];
	temp[6] = ux2*u.y*h_in[0] + ux2*h_in[2] + 2.*uxuy*h_in[1] + 2.*u.x*h_in[5] + u.y*h_in[3] + h_in[6];
	temp[7] = u.x*uy2*h_in[0] + 2.*uxuy*h_in[2] + u.x*h_in[4] + uy2*h_in[1] + 2.*u.y*h_in[5] + h_in[7];
	temp[8] = ux2*uy2*h_in[0] + 2.*ux2*u.y*h_in[2] + ux2*h_in[4] + 2.*u.x*uy2*h_in[1] + 4.*uxuy*h_in[5] + 2.*u.x*h_in[7] + uy2*h_in[3] + 2.*u.y*h_in[6] + h_in[8];
	//back to density-probability functions
	h_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	h_in[1] = 1/2.*temp[1] + 1/2.*temp[3] - 1/2.*temp[7] - 1/2.*temp[8];
	h_in[2] = 1/2.*temp[2] + 1/2.*temp[4] - 1/2.*temp[6] - 1/2.*temp[8];
	h_in[3] = -1/2.*temp[1] + 1/2.*temp[3] + 1/2.*temp[7] - 1/2.*temp[8];
	h_in[4] = -1/2.*temp[2] + 1/2.*temp[4] + 1/2.*temp[6] - 1/2.*temp[8];
	h_in[5] = 1/4.*temp[5] + 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
	h_in[6] = -1/4.*temp[5] + 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[7] = 1/4.*temp[5] - 1/4.*temp[6] - 1/4.*temp[7] + 1/4.*temp[8];
	h_in[8] = -1/4.*temp[5] - 1/4.*temp[6] + 1/4.*temp[7] + 1/4.*temp[8];
}


CudaDeviceFunction vector_t getForce(real_t localTemp, real_t rho)
{
	// Boussinesq approximation
	// rho(T) ~ rho_0*(1-thermal_exp_coeff*(Temp-Temp_0))
	// F_b = (rho(T) - rho_0)*Grav_Y = -Grav_Y*rho_0*thermal_exp_coeff*(Temp-Temp_0)
	// see chapter 8.4.1, eq 8.44, p313 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
	real_t refTemperature = 0;
	real_t BoussinesqForce = -GravitationY*BoussinesqCoeff*(localTemp - refTemperature); // BoussinesqCoeff=rho_0*thermal_exp_coeff

	vector_t Force; 
	Force.x = GravitationX*rho; 
	Force.y = GravitationY*rho+BoussinesqForce; 
	Force.z = 0;

	return Force;
}

CudaDeviceFunction void CollisionCM()
{
	real_t localTemperature = getT();
	real_t rho = getRho();

	vector_t Force = getForce(localTemperature, rho);
	vector_t u = getRawU();
	u.x += Force.x/(2*rho);
	u.y += Force.y/(2*rho);

	real_t omega_k = 1.0/(3*conductivity+0.5);
	relax_and_collide_ADE(h, rho, omega_k, u);  // TODO: a moze kolizja z nowym u po hydro kolizji ktora ma juz darcy stopper?

	// add Darcy force to stop flow within solid regions
	if ((NodeType & NODE_ADDITIONALS) == NODE_DarcySolid) 
	{
		vector_t fDarcyStoper = get_fDarcyStoper(rho,  u);
		Force.x += fDarcyStoper.x;
		Force.y += fDarcyStoper.y;
	} 
	relax_and_collide_hydro_with_F(f, rho, omega_nu, u, Force);	
}
