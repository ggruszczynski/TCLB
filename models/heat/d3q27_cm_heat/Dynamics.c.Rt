<?R 
    # c_header();
	source("conf.R")
	source("lib/feq.R")
	source("lib/boundary.R")
    source("lib/lattice.R")
    
    # Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	h = PV(DensityAll$name[DensityAll$group=="h"])
	rho =  PV("rho")
	u = PV(c("ux","uy","uz"))
	rhoT = PV("rhoT")

    # Creating variables for symbolic computations
	rho =  PV("rho")
	J = PV("J",c("x","y","z"))
	tmp = PV("tmp")

    # Extracting velocity set
	U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])

    
    # Calculating equlibrium density set
	source("lib/feq.R")
	EQ = MRT_eq(U, rho, J, ortogonal=FALSE);
?>

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getT(){
	return (<?R C(sum(h)) ?>)/(<?R C(sum(f)) ?>);
}

CudaDeviceFunction vector_t getU(){
	real_t d = getRho();
	vector_t u;
    <?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>

    // TODO:  dont forget to add force here later on
	u.x /= d;
	u.y /= d;
	u.z /= d;
	return u;
}

CudaDeviceFunction float2 Color() {
	float2 ret;
	vector_t u = getU();

	ret.x = getT();
	ret.y = ret.x;

	// ret.y = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);

	// if (NodeType == NODE_Solid){
	//         ret.y = 0;
	// } else {
	//         ret.y = 1;
	// }

	

	return ret;
}


CudaDeviceFunction void Init() {
	if((NodeType & NODE_BOUNDARY) == NODE_Wall){
		set_eq_hydro(1.0,0,0,0);
	}
	else{	
		real_t pressure = 0;
		set_eq_hydro(1.0 + pressure * 3.0, VelocityX, 0, 0);
	}

	real_t T = InitTemperature;
	vector_t u; u.x = VelocityX; u.y = 0; u.z = 0;
	set_eq_ADE(h,T,u);
}

CudaDeviceFunction void Run() {
    // switch (NodeType & NODE_BOUNDARY) {
	// // case NODE_EVelocity:
	// // 	EVelocity();
	// // 	break;
	// // case NODE_WPressure:
	// // 	WPressure();
	// // 	break;
	// // case NODE_WVelocity:
	// // 	WVelocity();
	// // 	break;
	// // case NODE_EPressure:
	// // 	EPressure();
	// // 	break;
	// case NODE_Wall:
    // 	BounceBack();
    //     break;
    // }

    if (NodeType & NODE_CM)
    {
		CollisionCM();
    }
}

CudaDeviceFunction void set_eq_hydro(real_t rho, real_t Jx, real_t Jy, real_t Jz)
{
	<?R
		C(f, EQ$Req %*% solve(EQ$mat));
	?>
}

CudaDeviceFunction void set_eq_ADE(real_t h_in[19], real_t H, vector_t u) 
{
	real_t uxuy = u.x*u.y;
	real_t uxuz = u.x*u.z;
	real_t uyuz = u.y*u.z;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	real_t uz2 = u.z*u.z;

	real_t m00 = H;
	real_t temp[19];


	//equilibrium in central moments space
	//collide
	h_in[0] = m00;
	h_in[1] = 0;
	h_in[2] = 0;
	h_in[3] = 0;
	h_in[4] = 0;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 1/3.*m00;
	h_in[8] = 1/3.*m00;
	h_in[9] = 1/3.*m00;
	h_in[10] = 0;
	h_in[11] = 0;
	h_in[12] = 0;
	h_in[13] = 0;
	h_in[14] = 0;
	h_in[15] = 0;
	h_in[16] = 1/9.*m00;
	h_in[17] = 1/9.*m00;
	h_in[18] = 1/9.*m00;

	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = h_in[0]*u.x + h_in[1];
	temp[2] = h_in[0]*u.y + h_in[2];
	temp[3] = h_in[0]*u.z + h_in[3];
	temp[4] = h_in[0]*uxuy + h_in[1]*u.y + h_in[2]*u.x + h_in[4];
	temp[5] = h_in[0]*uxuz + h_in[1]*u.z + h_in[3]*u.x + h_in[5];
	temp[6] = h_in[0]*uyuz + h_in[2]*u.z + h_in[3]*u.y + h_in[6];
	temp[7] = h_in[0]*ux2 + 2.*h_in[1]*u.x + h_in[7];
	temp[8] = h_in[0]*uy2 + 2.*h_in[2]*u.y + h_in[8];
	temp[9] = h_in[0]*uz2 + 2.*h_in[3]*u.z + h_in[9];
	temp[10] = h_in[0]*u.x*uy2 + h_in[10] + h_in[1]*uy2 + 2.*h_in[2]*uxuy + 2.*h_in[4]*u.y + h_in[8]*u.x;
	temp[11] = h_in[0]*u.x*uz2 + h_in[11] + h_in[1]*uz2 + 2.*h_in[3]*uxuz + 2.*h_in[5]*u.z + h_in[9]*u.x;
	temp[12] = h_in[0]*ux2*u.y + h_in[12] + 2.*h_in[1]*uxuy + h_in[2]*ux2 + 2.*h_in[4]*u.x + h_in[7]*u.y;
	temp[13] = h_in[0]*ux2*u.z + h_in[13] + 2.*h_in[1]*uxuz + h_in[3]*ux2 + 2.*h_in[5]*u.x + h_in[7]*u.z;
	temp[14] = h_in[0]*u.y*uz2 + h_in[14] + h_in[2]*uz2 + 2.*h_in[3]*uyuz + 2.*h_in[6]*u.z + h_in[9]*u.y;
	temp[15] = h_in[0]*uy2*u.z + h_in[15] + 2.*h_in[2]*uyuz + h_in[3]*uy2 + 2.*h_in[6]*u.y + h_in[8]*u.z;
	temp[16] = h_in[0]*ux2*uy2 + 2.*h_in[10]*u.x + 2.*h_in[12]*u.y + h_in[16] + 2.*h_in[1]*u.x*uy2 + 2.*h_in[2]*ux2*u.y + 4.*h_in[4]*uxuy + h_in[7]*uy2 + h_in[8]*ux2;
	temp[17] = h_in[0]*ux2*uz2 + 2.*h_in[11]*u.x + 2.*h_in[13]*u.z + h_in[17] + 2.*h_in[1]*u.x*uz2 + 2.*h_in[3]*ux2*u.z + 4.*h_in[5]*uxuz + h_in[7]*uz2 + h_in[9]*ux2;
	temp[18] = h_in[0]*uy2*uz2 + 2.*h_in[14]*u.y + 2.*h_in[15]*u.z + h_in[18] + 2.*h_in[2]*u.y*uz2 + 2.*h_in[3]*uy2*u.z + 4.*h_in[6]*uyuz + h_in[8]*uz2 + h_in[9]*uy2;

	//back to density-probability functions
	h_in[0] = temp[0] + temp[16] + temp[17] + temp[18] - temp[7] - temp[8] - temp[9];
	h_in[1] = -1/2.*temp[10] - 1/2.*temp[11] - 1/2.*temp[16] - 1/2.*temp[17] + 1/2.*temp[1] + 1/2.*temp[7];
	h_in[2] = 1/2.*temp[10] + 1/2.*temp[11] - 1/2.*temp[16] - 1/2.*temp[17] - 1/2.*temp[1] + 1/2.*temp[7];
	h_in[3] = -1/2.*temp[12] - 1/2.*temp[14] - 1/2.*temp[16] - 1/2.*temp[18] + 1/2.*temp[2] + 1/2.*temp[8];
	h_in[4] = 1/2.*temp[12] + 1/2.*temp[14] - 1/2.*temp[16] - 1/2.*temp[18] - 1/2.*temp[2] + 1/2.*temp[8];
	h_in[5] = -1/2.*temp[13] - 1/2.*temp[15] - 1/2.*temp[17] - 1/2.*temp[18] + 1/2.*temp[3] + 1/2.*temp[9];
	h_in[6] = 1/2.*temp[13] + 1/2.*temp[15] - 1/2.*temp[17] - 1/2.*temp[18] - 1/2.*temp[3] + 1/2.*temp[9];
	h_in[7] = 1/4.*temp[10] + 1/4.*temp[12] + 1/4.*temp[16] + 1/4.*temp[4];
	h_in[8] = -1/4.*temp[10] + 1/4.*temp[12] + 1/4.*temp[16] - 1/4.*temp[4];
	h_in[9] = 1/4.*temp[10] - 1/4.*temp[12] + 1/4.*temp[16] - 1/4.*temp[4];
	h_in[10] = -1/4.*temp[10] - 1/4.*temp[12] + 1/4.*temp[16] + 1/4.*temp[4];
	h_in[11] = 1/4.*temp[11] + 1/4.*temp[13] + 1/4.*temp[17] + 1/4.*temp[5];
	h_in[12] = -1/4.*temp[11] + 1/4.*temp[13] + 1/4.*temp[17] - 1/4.*temp[5];
	h_in[13] = 1/4.*temp[11] - 1/4.*temp[13] + 1/4.*temp[17] - 1/4.*temp[5];
	h_in[14] = -1/4.*temp[11] - 1/4.*temp[13] + 1/4.*temp[17] + 1/4.*temp[5];
	h_in[15] = 1/4.*temp[14] + 1/4.*temp[15] + 1/4.*temp[18] + 1/4.*temp[6];
	h_in[16] = -1/4.*temp[14] + 1/4.*temp[15] + 1/4.*temp[18] - 1/4.*temp[6];
	h_in[17] = 1/4.*temp[14] - 1/4.*temp[15] + 1/4.*temp[18] - 1/4.*temp[6];
	h_in[18] = -1/4.*temp[14] - 1/4.*temp[15] + 1/4.*temp[18] + 1/4.*temp[6];

}

CudaDeviceFunction void relax_and_collide_ADE(real_t h_in[19], real_t omega_v, vector_t u) 
{
	real_t uxuy = u.x*u.y;
	real_t uxuz = u.x*u.z;
	real_t uyuz = u.y*u.z;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	real_t uz2 = u.z*u.z;

	real_t m00 = h_in[0] + h_in[10] + h_in[11] + h_in[12] + h_in[13] + h_in[14] + h_in[15] + h_in[16] + h_in[17] + h_in[18] + h_in[1] + h_in[2] + h_in[3] + h_in[4] + h_in[5] + h_in[6] + h_in[7] + h_in[8] + h_in[9];

	real_t temp[19];

	for (int i = 0; i < 19; i++) {
		temp[i] = h_in[i];}

	//raw moments from density-probability functions
	h_in[0] = temp[0] + temp[10] + temp[11] + temp[12] + temp[13] + temp[14] + temp[15] + temp[16] + temp[17] + temp[18] + temp[1] + temp[2] + temp[3] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8] + temp[9];
	h_in[1] = -temp[10] + temp[11] - temp[12] + temp[13] - temp[14] + temp[1] - temp[2] + temp[7] - temp[8] + temp[9];
	h_in[2] = -temp[10] + temp[15] - temp[16] + temp[17] - temp[18] + temp[3] - temp[4] + temp[7] + temp[8] - temp[9];
	h_in[3] = temp[11] + temp[12] - temp[13] - temp[14] + temp[15] + temp[16] - temp[17] - temp[18] + temp[5] - temp[6];
	h_in[4] = temp[10] + temp[7] - temp[8] - temp[9];
	h_in[5] = temp[11] - temp[12] - temp[13] + temp[14];
	h_in[6] = temp[15] - temp[16] - temp[17] + temp[18];
	h_in[7] = temp[10] + temp[11] + temp[12] + temp[13] + temp[14] + temp[1] + temp[2] + temp[7] + temp[8] + temp[9];
	h_in[8] = temp[10] + temp[15] + temp[16] + temp[17] + temp[18] + temp[3] + temp[4] + temp[7] + temp[8] + temp[9];
	h_in[9] = temp[11] + temp[12] + temp[13] + temp[14] + temp[15] + temp[16] + temp[17] + temp[18] + temp[5] + temp[6];
	h_in[10] = -temp[10] + temp[7] - temp[8] + temp[9];
	h_in[11] = temp[11] - temp[12] + temp[13] - temp[14];
	h_in[12] = -temp[10] + temp[7] + temp[8] - temp[9];
	h_in[13] = temp[11] + temp[12] - temp[13] - temp[14];
	h_in[14] = temp[15] - temp[16] + temp[17] - temp[18];
	h_in[15] = temp[15] + temp[16] - temp[17] - temp[18];
	h_in[16] = temp[10] + temp[7] + temp[8] + temp[9];
	h_in[17] = temp[11] + temp[12] + temp[13] + temp[14];
	h_in[18] = temp[15] + temp[16] + temp[17] + temp[18];

	//central moments from raw moments
	temp[0] = h_in[0];
	temp[1] = -h_in[0]*u.x + h_in[1];
	temp[2] = -h_in[0]*u.y + h_in[2];
	temp[3] = -h_in[0]*u.z + h_in[3];
	temp[4] = h_in[0]*uxuy - h_in[1]*u.y - h_in[2]*u.x + h_in[4];
	temp[5] = h_in[0]*uxuz - h_in[1]*u.z - h_in[3]*u.x + h_in[5];
	temp[6] = h_in[0]*uyuz - h_in[2]*u.z - h_in[3]*u.y + h_in[6];
	temp[7] = h_in[0]*ux2 - 2.*h_in[1]*u.x + h_in[7];
	temp[8] = h_in[0]*uy2 - 2.*h_in[2]*u.y + h_in[8];
	temp[9] = h_in[0]*uz2 - 2.*h_in[3]*u.z + h_in[9];
	temp[10] = -h_in[0]*u.x*uy2 + h_in[10] + h_in[1]*uy2 + 2.*h_in[2]*uxuy - 2.*h_in[4]*u.y - h_in[8]*u.x;
	temp[11] = -h_in[0]*u.x*uz2 + h_in[11] + h_in[1]*uz2 + 2.*h_in[3]*uxuz - 2.*h_in[5]*u.z - h_in[9]*u.x;
	temp[12] = -h_in[0]*ux2*u.y + h_in[12] + 2.*h_in[1]*uxuy + h_in[2]*ux2 - 2.*h_in[4]*u.x - h_in[7]*u.y;
	temp[13] = -h_in[0]*ux2*u.z + h_in[13] + 2.*h_in[1]*uxuz + h_in[3]*ux2 - 2.*h_in[5]*u.x - h_in[7]*u.z;
	temp[14] = -h_in[0]*u.y*uz2 + h_in[14] + h_in[2]*uz2 + 2.*h_in[3]*uyuz - 2.*h_in[6]*u.z - h_in[9]*u.y;
	temp[15] = -h_in[0]*uy2*u.z + h_in[15] + 2.*h_in[2]*uyuz + h_in[3]*uy2 - 2.*h_in[6]*u.y - h_in[8]*u.z;
	temp[16] = h_in[0]*ux2*uy2 - 2.*h_in[10]*u.x - 2.*h_in[12]*u.y + h_in[16] - 2.*h_in[1]*u.x*uy2 - 2.*h_in[2]*ux2*u.y + 4.*h_in[4]*uxuy + h_in[7]*uy2 + h_in[8]*ux2;
	temp[17] = h_in[0]*ux2*uz2 - 2.*h_in[11]*u.x - 2.*h_in[13]*u.z + h_in[17] - 2.*h_in[1]*u.x*uz2 - 2.*h_in[3]*ux2*u.z + 4.*h_in[5]*uxuz + h_in[7]*uz2 + h_in[9]*ux2;
	temp[18] = h_in[0]*uy2*uz2 - 2.*h_in[14]*u.y - 2.*h_in[15]*u.z + h_in[18] - 2.*h_in[2]*u.y*uz2 - 2.*h_in[3]*uy2*u.z + 4.*h_in[6]*uyuz + h_in[8]*uz2 + h_in[9]*uy2;

	//collision in central moments space
	//collide
	h_in[0] = m00;
	h_in[1] = -temp[1]*(omega_v - 1.);
	h_in[2] = -temp[2]*(omega_v - 1.);
	h_in[3] = -temp[3]*(omega_v - 1.);
	h_in[4] = 0;
	h_in[5] = 0;
	h_in[6] = 0;
	h_in[7] = 1/3.*m00;
	h_in[8] = 1/3.*m00;
	h_in[9] = 1/3.*m00;
	h_in[10] = 0;
	h_in[11] = 0;
	h_in[12] = 0;
	h_in[13] = 0;
	h_in[14] = 0;
	h_in[15] = 0;
	h_in[16] = 1/9.*m00;
	h_in[17] = 1/9.*m00;
	h_in[18] = 1/9.*m00;

	//back to raw moments
	temp[0] = h_in[0];
	temp[1] = h_in[0]*u.x + h_in[1];
	temp[2] = h_in[0]*u.y + h_in[2];
	temp[3] = h_in[0]*u.z + h_in[3];
	temp[4] = h_in[0]*uxuy + h_in[1]*u.y + h_in[2]*u.x + h_in[4];
	temp[5] = h_in[0]*uxuz + h_in[1]*u.z + h_in[3]*u.x + h_in[5];
	temp[6] = h_in[0]*uyuz + h_in[2]*u.z + h_in[3]*u.y + h_in[6];
	temp[7] = h_in[0]*ux2 + 2.*h_in[1]*u.x + h_in[7];
	temp[8] = h_in[0]*uy2 + 2.*h_in[2]*u.y + h_in[8];
	temp[9] = h_in[0]*uz2 + 2.*h_in[3]*u.z + h_in[9];
	temp[10] = h_in[0]*u.x*uy2 + h_in[10] + h_in[1]*uy2 + 2.*h_in[2]*uxuy + 2.*h_in[4]*u.y + h_in[8]*u.x;
	temp[11] = h_in[0]*u.x*uz2 + h_in[11] + h_in[1]*uz2 + 2.*h_in[3]*uxuz + 2.*h_in[5]*u.z + h_in[9]*u.x;
	temp[12] = h_in[0]*ux2*u.y + h_in[12] + 2.*h_in[1]*uxuy + h_in[2]*ux2 + 2.*h_in[4]*u.x + h_in[7]*u.y;
	temp[13] = h_in[0]*ux2*u.z + h_in[13] + 2.*h_in[1]*uxuz + h_in[3]*ux2 + 2.*h_in[5]*u.x + h_in[7]*u.z;
	temp[14] = h_in[0]*u.y*uz2 + h_in[14] + h_in[2]*uz2 + 2.*h_in[3]*uyuz + 2.*h_in[6]*u.z + h_in[9]*u.y;
	temp[15] = h_in[0]*uy2*u.z + h_in[15] + 2.*h_in[2]*uyuz + h_in[3]*uy2 + 2.*h_in[6]*u.y + h_in[8]*u.z;
	temp[16] = h_in[0]*ux2*uy2 + 2.*h_in[10]*u.x + 2.*h_in[12]*u.y + h_in[16] + 2.*h_in[1]*u.x*uy2 + 2.*h_in[2]*ux2*u.y + 4.*h_in[4]*uxuy + h_in[7]*uy2 + h_in[8]*ux2;
	temp[17] = h_in[0]*ux2*uz2 + 2.*h_in[11]*u.x + 2.*h_in[13]*u.z + h_in[17] + 2.*h_in[1]*u.x*uz2 + 2.*h_in[3]*ux2*u.z + 4.*h_in[5]*uxuz + h_in[7]*uz2 + h_in[9]*ux2;
	temp[18] = h_in[0]*uy2*uz2 + 2.*h_in[14]*u.y + 2.*h_in[15]*u.z + h_in[18] + 2.*h_in[2]*u.y*uz2 + 2.*h_in[3]*uy2*u.z + 4.*h_in[6]*uyuz + h_in[8]*uz2 + h_in[9]*uy2;

	//back to density-probability functions
	h_in[0] = temp[0] + temp[16] + temp[17] + temp[18] - temp[7] - temp[8] - temp[9];
	h_in[1] = -1/2.*temp[10] - 1/2.*temp[11] - 1/2.*temp[16] - 1/2.*temp[17] + 1/2.*temp[1] + 1/2.*temp[7];
	h_in[2] = 1/2.*temp[10] + 1/2.*temp[11] - 1/2.*temp[16] - 1/2.*temp[17] - 1/2.*temp[1] + 1/2.*temp[7];
	h_in[3] = -1/2.*temp[12] - 1/2.*temp[14] - 1/2.*temp[16] - 1/2.*temp[18] + 1/2.*temp[2] + 1/2.*temp[8];
	h_in[4] = 1/2.*temp[12] + 1/2.*temp[14] - 1/2.*temp[16] - 1/2.*temp[18] - 1/2.*temp[2] + 1/2.*temp[8];
	h_in[5] = -1/2.*temp[13] - 1/2.*temp[15] - 1/2.*temp[17] - 1/2.*temp[18] + 1/2.*temp[3] + 1/2.*temp[9];
	h_in[6] = 1/2.*temp[13] + 1/2.*temp[15] - 1/2.*temp[17] - 1/2.*temp[18] - 1/2.*temp[3] + 1/2.*temp[9];
	h_in[7] = 1/4.*temp[10] + 1/4.*temp[12] + 1/4.*temp[16] + 1/4.*temp[4];
	h_in[8] = -1/4.*temp[10] + 1/4.*temp[12] + 1/4.*temp[16] - 1/4.*temp[4];
	h_in[9] = 1/4.*temp[10] - 1/4.*temp[12] + 1/4.*temp[16] - 1/4.*temp[4];
	h_in[10] = -1/4.*temp[10] - 1/4.*temp[12] + 1/4.*temp[16] + 1/4.*temp[4];
	h_in[11] = 1/4.*temp[11] + 1/4.*temp[13] + 1/4.*temp[17] + 1/4.*temp[5];
	h_in[12] = -1/4.*temp[11] + 1/4.*temp[13] + 1/4.*temp[17] - 1/4.*temp[5];
	h_in[13] = 1/4.*temp[11] - 1/4.*temp[13] + 1/4.*temp[17] - 1/4.*temp[5];
	h_in[14] = -1/4.*temp[11] - 1/4.*temp[13] + 1/4.*temp[17] + 1/4.*temp[5];
	h_in[15] = 1/4.*temp[14] + 1/4.*temp[15] + 1/4.*temp[18] + 1/4.*temp[6];
	h_in[16] = -1/4.*temp[14] + 1/4.*temp[15] + 1/4.*temp[18] - 1/4.*temp[6];
	h_in[17] = 1/4.*temp[14] - 1/4.*temp[15] + 1/4.*temp[18] - 1/4.*temp[6];
	h_in[18] = -1/4.*temp[14] - 1/4.*temp[15] + 1/4.*temp[18] + 1/4.*temp[6];

}

CudaDeviceFunction vector_t relax_and_collide_hydro(vector_t Force, real_t omega)
{	
 	real_t w[10] = {omega,1.,1.,1.,1.,1.,1.,1.,1.,1.};
	if ((NodeType & NODE_BOUNDARY) != 0) w[0] = 1.0/(3*nubuffer+0.5);
	  
	f000 = f200 + f100 + f000; f100 = -f200 + f100; f200 = f100 + f200*2.; 
	f010 = f210 + f110 + f010; f110 = -f210 + f110; f210 = f110 + f210*2.; 
	f020 = f220 + f120 + f020; f120 = -f220 + f120; f220 = f120 + f220*2.; 
	f001 = f201 + f101 + f001; f101 = -f201 + f101; f201 = f101 + f201*2.; 
	f011 = f211 + f111 + f011; f111 = -f211 + f111; f211 = f111 + f211*2.; 
	f021 = f221 + f121 + f021; f121 = -f221 + f121; f221 = f121 + f221*2.; 
	f002 = f202 + f102 + f002; f102 = -f202 + f102; f202 = f102 + f202*2.; 
	f012 = f212 + f112 + f012; f112 = -f212 + f112; f212 = f112 + f212*2.; 
	f022 = f222 + f122 + f022; f122 = -f222 + f122; f222 = f122 + f222*2.; 
	f000 = f020 + f010 + f000; f010 = -f020 + f010; f020 = f010 + f020*2.; 
	f100 = f120 + f110 + f100; f110 = -f120 + f110; f120 = f110 + f120*2.; 
	f200 = f220 + f210 + f200; f210 = -f220 + f210; f220 = f210 + f220*2.; 
	f001 = f021 + f011 + f001; f011 = -f021 + f011; f021 = f011 + f021*2.; 
	f101 = f121 + f111 + f101; f111 = -f121 + f111; f121 = f111 + f121*2.; 
	f201 = f221 + f211 + f201; f211 = -f221 + f211; f221 = f211 + f221*2.; 
	f002 = f022 + f012 + f002; f012 = -f022 + f012; f022 = f012 + f022*2.; 
	f102 = f122 + f112 + f102; f112 = -f122 + f112; f122 = f112 + f122*2.; 
	f202 = f222 + f212 + f202; f212 = -f222 + f212; f222 = f212 + f222*2.; 
	f000 = f002 + f001 + f000; f001 = -f002 + f001; f002 = f001 + f002*2.; 
	f100 = f102 + f101 + f100; f101 = -f102 + f101; f102 = f101 + f102*2.; 
	f200 = f202 + f201 + f200; f201 = -f202 + f201; f202 = f201 + f202*2.; 
	f010 = f012 + f011 + f010; f011 = -f012 + f011; f012 = f011 + f012*2.; 
	f110 = f112 + f111 + f110; f111 = -f112 + f111; f112 = f111 + f112*2.; 
	f210 = f212 + f211 + f210; f211 = -f212 + f211; f212 = f211 + f212*2.; 
	f020 = f022 + f021 + f020; f021 = -f022 + f021; f022 = f021 + f022*2.; 
	f120 = f122 + f121 + f120; f121 = -f122 + f121; f122 = f121 + f122*2.; 
	f220 = f222 + f221 + f220; f221 = -f222 + f221; f222 = f221 + f222*2.; 


	<?R
		cumulants = paste("c",P$x,P$y,P$z,sep="");
		for (i in cumulants) { ?>
		real_t <?%s i ?>;
	<?R } ?>	


	c100 = f100/f000;
	c200 = ( -c100*f100 + f200 )/f000;
	c010 = f010/f000;
	c110 = ( -c100*f010 + f110 )/f000;
	c210 = ( -c110*f100 - c200*f010 - c100*f110 + f210 )/f000;
	c020 = ( -c010*f010 + f020 )/f000;
	c120 = ( -c100*f020 + f120 - c110*f010*2. )/f000;
	c220 = ( -c120*f100 - c200*f020 - c100*f120 + f220 + ( -c210*f010 - c110*f110 )*2. )/f000;
	c001 = f001/f000;
	c101 = ( -c100*f001 + f101 )/f000;
	c201 = ( -c101*f100 - c200*f001 - c100*f101 + f201 )/f000;
	c011 = ( -c010*f001 + f011 )/f000;
	c111 = ( -c101*f010 - c110*f001 - c100*f011 + f111 )/f000;
	c211 = ( -c011*f200 - c210*f001 - c010*f201 + f211 + ( -c111*f100 - c110*f101 )*2. )/f000;
	c021 = ( -c011*f010 - c020*f001 - c010*f011 + f021 )/f000;
	c121 = ( -c101*f020 - c120*f001 - c100*f021 + f121 + ( -c111*f010 - c110*f011 )*2. )/f000;
	c221 = ( -c021*f200 - c201*f020 - c001*f220 + f221 + ( -c121*f100 - c211*f010 - c011*f210 - c101*f120 - c111*f110*2. )*2. )/f000;
	c002 = ( -c001*f001 + f002 )/f000;
	c102 = ( -c100*f002 + f102 - c101*f001*2. )/f000;
	c202 = ( -c102*f100 - c200*f002 - c100*f102 + f202 + ( -c201*f001 - c101*f101 )*2. )/f000;
	c012 = ( -c010*f002 + f012 - c011*f001*2. )/f000;
	c112 = ( -c102*f010 - c110*f002 - c100*f012 + f112 + ( -c111*f001 - c101*f011 )*2. )/f000;
	c212 = ( -c012*f200 - c210*f002 - c010*f202 + f212 + ( -c112*f100 - c211*f001 - c011*f201 - c110*f102 - c111*f101*2. )*2. )/f000;
	c022 = ( -c012*f010 - c020*f002 - c010*f012 + f022 + ( -c021*f001 - c011*f011 )*2. )/f000;
	c122 = ( -c102*f020 - c120*f002 - c100*f022 + f122 + ( -c112*f010 - c121*f001 - c101*f021 - c110*f012 - c111*f011*2. )*2. )/f000;
	c222 = ( -c122*f100 - c202*f020 - c102*f120 - c220*f002 - c120*f102 - c200*f022 - c100*f122 + f222 + ( -c212*f010 - c112*f110 - c221*f001 - c121*f101 - c201*f021 - c101*f121 - c210*f012 - c110*f112 + ( -c211*f011 - c111*f111 )*2. )*2. )/f000;

	//Getting the velocity from the cummulants and force term
	vector_t u;
	u.x = c100 + Force.x/(2.*f000);
	u.y = c010 + Force.y/(2.*f000);
	u.z = c001 + Force.z/(2.*f000);

	#ifdef OPTIONS_SMAG
		//Calculating turbulent viscosity for Smagorinsky  turbulence model
		real_t tau_0 = 1./omega;
		real_t tau_t;
		real_t q;

		q = sqrt((c200-1.0/3)*(c200-1.0/3)+(c020-1.0/3)*(c020-1.0/3)+(c002-1.0/3)*(c002-1.0/3)+2*(c110*c110)+2*(c101*c101)+2*(c011*c011));
		tau_t = 0.5 * (sqrt( tau_0 * tau_0 + 18 * Smag * Smag * q) - tau_0);
		w[0] = 1.0 / (tau_0 + tau_t);

		if ((NodeType & NODE_BOUNDARY) != 0) w[0] = 1.0/(3*nubuffer+0.5);
	#endif
	
	// Galilean Correction 
	real_t dxu,dyv,dzw;
	dxu = - w[0]/(2.)*(2*c200 - c020 - c002) - w[1]/(2.)*(c200 + c020 + c002 - 1.);
	dyv = dxu + 3.*w[0]/2.*(c200 - c020);
	dzw = dxu + 3.*w[0]/2.*(c200 - c002);
	real_t gcor1 = 3.*(1 - w[0]/2.)*(u.x*u.x*dxu - u.y*u.y*dyv);
	real_t gcor2 = 3.*(1 - w[0]/2.)*(u.x*u.x*dxu - u.z*u.z*dzw);
	real_t gcor3 = 3.*(1 - w[1]/2.)*(u.x*u.x*dxu + u.y*u.y*dyv + u.z*u.z*dzw);
	real_t a,b,cc;
	a = (1 - w[0])*(c200 - c020);
	b = (1 - w[0])*(c200 - c002);
	cc = w[1] + (1 - w[1])*(c200 + c020 + c002);
	a = a - gcor1 * GalileanCorrection;
	b = b - gcor2 * GalileanCorrection;
	cc = cc - gcor3 * GalileanCorrection;

	//Cumulants relation 

 	c100 = c100 + Force.x;//100 - change only due to force term

	c200 = (a + b + cc)/3.;   //200
	c020 = (cc - 2*a + b)/3.; //020
	c002 = (cc - 2*b + a)/3.; 

	c010 = c010 + Force.y;  //010 - change only due to force term
	c001 = c001 + Force.z ; //001 - change only due to force term

	c110 = c110 * (1-w[0]);
	c011 = c011 * (1-w[0]);
	c101 = c101 * (1-w[0]);
	//Optional change in relaxation rate of 3rd order cumulants, as per car studies done by Geier et al
	<?R	sel = rowSums(P) == 3
		for (i in cumulants[sel]) { ?>
		<?%s i ?> = (1-Omegafor3rdCumulants)*<?%s i ?>;
	<?R } ?>

	<?R	sel = rowSums(P) > 3
		for (i in cumulants[sel]) { ?>
		<?%s i ?> = 0.0;
	<?R } ?>

	/////////
	f000 = f000;
	f100 = c100*f000;
	f200 = c200*f000 + c100*f100;
	f010 = c010*f000;
	f110 = c110*f000 + c100*f010;
	f210 = c210*f000 + c110*f100 + c200*f010 + c100*f110;
	f020 = c020*f000 + c010*f010;
	f120 = c120*f000 + c100*f020 + c110*f010*2.;
	f220 = c220*f000 + c120*f100 + c200*f020 + c100*f120 + ( c210*f010 + c110*f110 )*2.;
	f001 = c001*f000;
	f101 = c101*f000 + c100*f001;
	f201 = c201*f000 + c101*f100 + c200*f001 + c100*f101;
	f011 = c011*f000 + c010*f001;
	f111 = c111*f000 + c101*f010 + c110*f001 + c100*f011;
	f211 = c211*f000 + c011*f200 + c210*f001 + c010*f201 + ( c111*f100 + c110*f101 )*2.;
	f021 = c021*f000 + c011*f010 + c020*f001 + c010*f011;
	f121 = c121*f000 + c101*f020 + c120*f001 + c100*f021 + ( c111*f010 + c110*f011 )*2.;
	f221 = c221*f000 + c021*f200 + c201*f020 + c001*f220 + ( c121*f100 + c211*f010 + c011*f210 + c101*f120 + c111*f110*2. )*2.;
	f002 = c002*f000 + c001*f001;
	f102 = c102*f000 + c100*f002 + c101*f001*2.;
	f202 = c202*f000 + c102*f100 + c200*f002 + c100*f102 + ( c201*f001 + c101*f101 )*2.;
	f012 = c012*f000 + c010*f002 + c011*f001*2.;
	f112 = c112*f000 + c102*f010 + c110*f002 + c100*f012 + ( c111*f001 + c101*f011 )*2.;
	f212 = c212*f000 + c012*f200 + c210*f002 + c010*f202 + ( c112*f100 + c211*f001 + c011*f201 + c110*f102 + c111*f101*2. )*2.;
	f022 = c022*f000 + c012*f010 + c020*f002 + c010*f012 + ( c021*f001 + c011*f011 )*2.;
	f122 = c122*f000 + c102*f020 + c120*f002 + c100*f022 + ( c112*f010 + c121*f001 + c101*f021 + c110*f012 + c111*f011*2. )*2.;
	f222 = c222*f000 + c122*f100 + c202*f020 + c102*f120 + c220*f002 + c120*f102 + c200*f022 + c100*f122 + ( c212*f010 + c112*f110 + c221*f001 + c121*f101 + c201*f021 + c101*f121 + c210*f012 + c110*f112 + ( c211*f011 + c111*f111 )*2. )*2.;

	f000 = -f200 + f000; f100 = ( f200 + f100 )/2.; f200 = f200 - f100; 
	f010 = -f210 + f010; f110 = ( f210 + f110 )/2.; f210 = f210 - f110; 
	f020 = -f220 + f020; f120 = ( f220 + f120 )/2.; f220 = f220 - f120; 
	f001 = -f201 + f001; f101 = ( f201 + f101 )/2.; f201 = f201 - f101; 
	f011 = -f211 + f011; f111 = ( f211 + f111 )/2.; f211 = f211 - f111; 
	f021 = -f221 + f021; f121 = ( f221 + f121 )/2.; f221 = f221 - f121; 
	f002 = -f202 + f002; f102 = ( f202 + f102 )/2.; f202 = f202 - f102; 
	f012 = -f212 + f012; f112 = ( f212 + f112 )/2.; f212 = f212 - f112; 
	f022 = -f222 + f022; f122 = ( f222 + f122 )/2.; f222 = f222 - f122; 
	f000 = -f020 + f000; f010 = ( f020 + f010 )/2.; f020 = f020 - f010; 
	f100 = -f120 + f100; f110 = ( f120 + f110 )/2.; f120 = f120 - f110; 
	f200 = -f220 + f200; f210 = ( f220 + f210 )/2.; f220 = f220 - f210; 
	f001 = -f021 + f001; f011 = ( f021 + f011 )/2.; f021 = f021 - f011; 
	f101 = -f121 + f101; f111 = ( f121 + f111 )/2.; f121 = f121 - f111; 
	f201 = -f221 + f201; f211 = ( f221 + f211 )/2.; f221 = f221 - f211; 
	f002 = -f022 + f002; f012 = ( f022 + f012 )/2.; f022 = f022 - f012; 
	f102 = -f122 + f102; f112 = ( f122 + f112 )/2.; f122 = f122 - f112; 
	f202 = -f222 + f202; f212 = ( f222 + f212 )/2.; f222 = f222 - f212; 
	f000 = -f002 + f000; f001 = ( f002 + f001 )/2.; f002 = f002 - f001; 
	f100 = -f102 + f100; f101 = ( f102 + f101 )/2.; f102 = f102 - f101; 
	f200 = -f202 + f200; f201 = ( f202 + f201 )/2.; f202 = f202 - f201; 
	f010 = -f012 + f010; f011 = ( f012 + f011 )/2.; f012 = f012 - f011; 
	f110 = -f112 + f110; f111 = ( f112 + f111 )/2.; f112 = f112 - f111; 
	f210 = -f212 + f210; f211 = ( f212 + f211 )/2.; f212 = f212 - f211; 
	f020 = -f022 + f020; f021 = ( f022 + f021 )/2.; f022 = f022 - f021; 
	f120 = -f122 + f120; f121 = ( f122 + f121 )/2.; f122 = f122 - f121; 
	f220 = -f222 + f220; f221 = ( f222 + f221 )/2.; f222 = f222 - f221;
	
	return u;
}



CudaDeviceFunction void CollisionCM(){

	// real_t myPhaseF = PhaseF(0,0);

	// // Find Macroscopic Details
	// real_t rho = calcRho(myPhaseF);
	// real_t tau = calcTau(myPhaseF, rho);
	// real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);

	// //  Gradients & Normals
	// vector_t gradPhi = calcGradPhi(); // Phase field gradient
	// real_t p = getNormalizedPressure(); // normalized pressure

	// vector_t Fhydro = calcTotalHydrodynamicForceCM(gradPhi, myPhaseF, rho, tau,  calcMu(myPhaseF), p);

	// // PHASE FIELD POPULATION UPDATE:
	// vector_t u; u.x = U; u.y = V;
	// vector_t F_phi_vect = calcF_phi_xy(gradPhi,  myPhaseF,  pfavg);
	// AddToF_phiX(F_phi_vect.x);
	// AddToF_phiY(F_phi_vect.y);


	
	//  PRESSURE EVOLUTION UPDATE:
	// relax_and_collide_CM_hydro(g, tau, u, Fhydro, rho);

///////////////////////////////////////////
	real_t localTemperature = getT();
	real_t refTemperature = 0;
	real_t BoussinesqForce = GravitationY - GravitationY*BoussinesqCoeff*(localTemperature - refTemperature);

	vector_t Force; Force.x = 0; Force.y = BoussinesqForce; Force.z = 0;
	vector_t u = relax_and_collide_hydro(Force, omega_nu);

	// u.x = VelocityX; u.y = 0; u.z = 0;
	relax_and_collide_ADE(h, omega_k, u);
}
