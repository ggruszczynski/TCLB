<?R 
	source("conf.R")
	c_header();
	source("lib/feq.R")
	source("lib/boundary.R")
	source("lib/lattice.R")
?>

// 04/02/2017 - Model Developed: A. Fakhari, T. Mitchell
//	      - Implementation:	 T. Mitchell

// Model for Physical Review E article:
//
// """" Improved locality of the phase-field lattice Boltzmann 
//	model for immiscible fluids at high density ratios 	    """"
//
// Authors: A. Fakhari, T. Mitchell, C. Leonardi, D. Bolster (2017) """"
// DOI: 10.1103/PhysRevE.96.053301


// Maintainer: Travis-Mitchell @TravisMitchell
// Code updates:
//		04/02/2017: Development starts...
//		- Verification/Validation:
//			Poiseuille flow
//			Rayleigh Taylor
//			Taylor bubble rise
//		24/07/2017: Options added for Reviewer comments:
//			  : didn't notice any macroscopic difference in soln's
//			- A: Higher order Guo forcing term
//			- B: Time dependent term in phase field from Ren et al (2016)
//		14/08/2017: Added in boundary conditions:
// 			- Moving walls seem to work well for bubble deformation
//			- Pressure/velocity not fully tested - use at your own PERIL!


// Maintainer & Implementation: Grzegorz Gruszczynski @ggruszczynski
// Code updates:
//		16/08/2018: Cascaded collision scheme

#include <math.h>
#define PI 3.1415926535897

<?R
g = PV(Density$name[Density$group == "g"])
h = PV(Density$name[Density$group == "h"])

if (Options$Outflow){
	g_neighbours = Density$nicename[Density$group == "g"]
	h_neighbours = Density$nicename[Density$group == "h"]
	g_old = PV(Density$name[Density$group == "gold"])
	h_old = PV(Density$name[Density$group == "hold"])
	g_n = PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],")",sep=""))
	h_n = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")",sep=""))
	g_n1 = PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"],",",-Density$dy[Density$group=="g"]-1,")",sep=""))
	h_n1 = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"],",",-Density$dy[Density$group=="h"]-1,")",sep=""))
	U_loc = PV("U_local")
	U_inv = PV("invU")
}
?>
//	EXPORTABLE QUANTITIES:
CudaDeviceFunction real_t getRho(){
	real_t rho;
	rho = Density_l + (Density_h-Density_l) * (PhaseF(0,0) - PhaseField_l)/(PhaseField_h - PhaseField_l);
	return rho;
}

CudaDeviceFunction real_t getPorosity(){
	return poro0; 
}

CudaDeviceFunction real_t getIBPermability(){
	return IB_permability; 
}


CudaDeviceFunction real_t getPhaseField(){
	return PhaseF(0,0);
}

CudaDeviceFunction vector_t getU(){
	vector_t u;
	u.x = U;
	u.y = V;
	u.z = 0.0;
	return u;
}

CudaDeviceFunction real_t getNormalizedPressure(){
	// Normalised pressure, eq 32a from "Improved locality of the phase-field lattice Boltzmann 
	//model for immiscible fluids at high density ratios"
	real_t p =  <?R C(sum(g)) ?> ;
	return p;
}

CudaDeviceFunction real_t getPressure(){
	// Pressure, defined just eq 17 from "Improved locality of the phase-field lattice Boltzmann 
	//	model for immiscible fluids at high density ratios"
	real_t p =  <?R C(sum(g)) ?> ;//Normalised pressure
	real_t rho = getRho();
	p = p*rho/3.0; 
	return p;
}

CudaDeviceFunction vector_t getNormal(){
	vector_t normal;
	normal.x = nw_x;
	normal.y = nw_y;
	normal.z = 0.0;
	return normal;
}

// 	HELPER FUNCTIONS:
CudaDeviceFunction vector_t calcGradPhi(){
	vector_t gradPhi;
	// eq 34 from "Improved locality of the phase-field lattice Boltzmann 
	//	model for immiscible fluids at high density ratios"
	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Neumann_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_E) {
			gradPhi.x = 0.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(-1,1) - PhaseF(-1,-1) )/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Convective_N) {
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,-1) - PhaseF(-1,-1) )/6.0;
			gradPhi.y = 0.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		} else if (NodeType & NODE_BOUNDARY){
			gradPhi.x = 0.0;
			gradPhi.y = 0.0;
		} else { 
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		}
	#else
		if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		} else if (NodeType & NODE_BOUNDARY){
			gradPhi.x = 0.0;
			gradPhi.y = 0.0;
		} else { 
			gradPhi.x = (PhaseF(1,0) - PhaseF(-1,0))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(1,-1) - PhaseF(-1,1))/12.0;
			gradPhi.y = (PhaseF(0,1) - PhaseF(0,-1))/3.0 + (PhaseF(1,1) - PhaseF(-1,-1) + PhaseF(-1,1) - PhaseF(1,-1))/12.0;
		}
	#endif
	gradPhi.x *= PF2NS_coupling;
	gradPhi.y *= PF2NS_coupling;
	gradPhi.z = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + 1e-12); // length


	return gradPhi;
}

CudaDeviceFunction real_t get_lpPhi(real_t myPhase){
	// input myPhase - PhaseF at given node (usually 0,0 or the one from BC)

	// lpPhi - eq 35 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t lpPhi = PhaseF(1,1)+PhaseF(-1,1)+PhaseF(1,-1)+PhaseF(-1,-1)
	               + 4.0*(PhaseF(1,0)+PhaseF(-1,0)+PhaseF(0,1)+PhaseF(0,-1))
	               - 20.0*myPhase;
	lpPhi /= 6.0;

	return (PF2NS_coupling*lpPhi + 1e-12);
}

CudaDeviceFunction real_t calcMu(real_t myPhase){
	// input myPhase - PhaseF at given node (usually 0,0 or the one from BC)

	real_t lpPhi;

	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Neumann_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_E) {
			lpPhi = (PhaseF(-1,1)+PhaseF(-1,1)+PhaseF(-1,-1)+PhaseF(-1,-1) +
						4.0*(PhaseF(-1,0)+PhaseF(-1,0)+PhaseF(0,1)+PhaseF(0,-1) ) -
						20.0*myPhase)/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Convective_N) {
			lpPhi = (PhaseF(1,-1)+PhaseF(-1,-1)+PhaseF(1,-1)+PhaseF(-1,-1) +
						4.0*(PhaseF(1,0)+PhaseF(-1,0)+PhaseF(0,-1)+PhaseF(0,-1) ) -
						20.0*myPhase)/6.0;
		} else if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			lpPhi = get_lpPhi(myPhase);
		} else if (NodeType & NODE_BOUNDARY){
			lpPhi = 0.0;
		} else {
			lpPhi = get_lpPhi(myPhase);
		}
	#else
		if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
			lpPhi = get_lpPhi(myPhase);
		} else if (NodeType & NODE_BOUNDARY){
			lpPhi = 0.0;
		} else {
			lpPhi = get_lpPhi(myPhase);
		}
	#endif

	// eq 5 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
	real_t mu = 4.0*(12.0*sigma/W)*(myPhase-PhaseField_l)*(myPhase-PhaseField_h)*(myPhase-pfavg)
		        - (1.5 *sigma*W) * lpPhi; 
	return mu;
}

CudaDeviceFunction real_t calcGamma(int i, real_t u, real_t v, real_t u2mag){
	// eq 10 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"
	real_t gamma, tmp;
	tmp = (d2q9_ex[i]*u+d2q9_ey[i]*v);

	gamma = wf[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcF_phi(int i, real_t numerator, real_t nx, real_t ny){
	// eq 7 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"

	// nx: normalized PhaseField gradient in x direction
	// this method calculates F_phi in [0-9] lattice coord

	real_t f_phi;
	f_phi = PF_counterdiff_coeff * wf[i] * numerator * (d2q9_ex[i]*nx + d2q9_ey[i]*ny);
	return f_phi;
}

CudaDeviceFunction vector_t calcF_phi_xy(vector_t gradPhi, real_t myPhaseF, real_t pfavg){	
	// eq 7 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"

	// this method calculates F_phi in x,y coordinates
	real_t nx = gradPhi.x/gradPhi.z;  // GradPhi normalized in x, y direction
	real_t ny = gradPhi.y/gradPhi.z;

	real_t F_phi_coeff = (PF_counterdiff_coeff)*(1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/(3.0*W);

	vector_t f_phi;	
	f_phi.x=F_phi_coeff*nx;
	f_phi.y=F_phi_coeff*ny;
	return f_phi;
}

CudaDeviceFunction real_t calcDynVisc(real_t myPhaseF, real_t myRho)
{
	real_t normPhaseF = (myPhaseF - PhaseField_l)/(PhaseField_h - PhaseField_l);
	real_t DynVisc = Density_l*Viscosity_l + normPhaseF* (Density_h*Viscosity_h - Density_l*Viscosity_l);
	return DynVisc;
}

CudaDeviceFunction real_t calcTau(real_t myPhaseF, real_t myRho)
{
	real_t tau;

	if ( myPhaseF < PhaseField_l){
		tau = tau_l + 0.5;
	} else if (myPhaseF > PhaseField_h) {
		tau = tau_h + 0.5;
	} else {
		real_t normPhaseF = (myPhaseF - PhaseField_l)/(PhaseField_h - PhaseField_l);
		// Linear update: eq23
		tau = 0.5 + tau_l + normPhaseF*(tau_h - tau_l);

	// There are a number of ways to update the relaxation time through the interface
	//		a number of these are supplied here for the interested user:
	// Inverse update: eq22
		//tau = normPhaseF * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
		//tau = 1.0/tau + 0.5;

	// Sharp update:		
		// real_t pf_avg = (PhaseField_h + PhaseField_l)/2.;
		// tau = (myPhaseF >= pf_avg) ? 0.5 + tau_h : 0.5 + tau_l;
		// real_t mu_h = Viscosity_h * myRho;
		// real_t mu_l = Viscosity_l * myRho;
		// tau = (myPhaseF >= pf_avg) ? 0.5 + 3*mu_h/Density_h : 0.5 + 3*mu_l/Density_l;

	// Viscosity update: eq24 & 25
		// real_t DynVisc = calcDynVisc(myPhaseF, myRho)
		// tau = 3.0 * DynVisc / myRho + 0.5;
	
	// Zu and He (2013): eq29c
		// real_t DynVisc = Density_l*Viscosity_l * Density_h*Viscosity_h * (PhaseField_h - PhaseField_l)
		//					/ ((myPhaseF-PhaseField_l)*Density_l*Viscosity_l  
		//					  +(PhaseField_h-myPhaseF)*Density_h*Viscosity_h    ) ;
		// tau = 3.0 * DynVisc / myRho + 0.5;
	}

	return tau;
}

CudaDeviceFunction real_t calcRho(real_t myPhaseF)
{
	// Linear update:
	real_t rho = Density_l + (myPhaseF - PhaseField_l)*(Density_h - Density_l) / (PhaseField_h - PhaseField_l);
	
	// Sharp update:
	// 	not recommended
	// real_t pf_avg = (PhaseField_h + PhaseField_l)/2.;
	// real_t rho = (myPhaseF >= pf_avg) ? Density_h : Density_l;
	return rho;
}

//	INITIALISATION:
CudaDeviceFunction void Init_phase() {
	PhaseF = PhaseField_init;// read initial PhaseField distribution from config.xml file
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) PhaseF = -999;
}


CudaDeviceFunction void Init_wallNorm(){
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) {
		int solidFlags[9], i;
		solidFlags[0] = PhaseF(0,0)  /-998;
		solidFlags[1] = PhaseF(1,0)  /-998;
		solidFlags[2] = PhaseF(0,1)  /-998;
		solidFlags[3] = PhaseF(-1,0) /-998;
		solidFlags[4] = PhaseF(0,-1) /-998;
		solidFlags[5] = PhaseF(1,1)  /-998;
		solidFlags[6] = PhaseF(-1,1 )/-998;
		solidFlags[7] = PhaseF(-1,-1)/-998;
		solidFlags[8] = PhaseF(1,-1) /-998;

		real_t myNorm[2]={0.0,0.0};
		for (i = 0 ; i < 9; i++){
			myNorm[0] += wf[i]*d2q9_ex[i]*solidFlags[i];
			myNorm[1] += wf[i]*d2q9_ey[i]*solidFlags[i];	
		}
		myNorm[0] *= -1.0/3.0;
		myNorm[1] *= -1.0/3.0;

		real_t dot, maxn=0.0;
		int maxi=0;

		for (i = 0; i<9; i++) {
			dot = (myNorm[0]*d2q9_ex[i] + myNorm[1]*d2q9_ey[i])/ 
			      sqrt( (myNorm[0]*myNorm[0] + myNorm[1]*myNorm[1])*(d2q9_ex[i]*d2q9_ex[i] + d2q9_ey[i]*d2q9_ey[i]+1e-12 ));
		
			if (dot > maxn) {
				maxn = dot;
				maxi = i;
			}
		}

		nw_x = d2q9_ex[maxi];
		nw_y = d2q9_ey[maxi];
	} else {
		nw_x = 0.0; nw_y = 0.0;
	}
}

CudaDeviceFunction void PF_Dirichlet_EQ()
{
	real_t myPhaseF = PhaseField_init;

	vector_t gradPhi = calcGradPhi();
	real_t nx, ny;
	// gradPhi.z stores the magnitude of the vector
	nx = gradPhi.x/gradPhi.z;
	ny = gradPhi.y/gradPhi.z;

		// U = VelocityX;
		// V = VelocityY;
	real_t mag = U*U + V*V;
	real_t Gamma[9], F_phi[9];
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
	real_t tmp1 = (1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/W;

	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, U, V, mag);
		F_phi[i] = calcF_phi(i, tmp1, nx, ny);
		h[i] = myPhaseF * Gamma[i] - 0.5*F_phi[i];   // heq
	}

}

CudaDeviceFunction void Init_distributions(){
	
	// Find Gradients and normals:
	real_t myPhaseF = PhaseF(0,0);

	vector_t gradPhi = calcGradPhi();
	real_t nx, ny;
	// gradPhi.z stores the magnitude of the vector
	nx = gradPhi.x/gradPhi.z;
	ny = gradPhi.y/gradPhi.z;

	// Define Equilibrium, then initialise all da things
	U = VelocityX;
	V = VelocityY;
	real_t mag = U*U + V*V;

	real_t Gamma[9], F_phi[9];
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);
	real_t tmp1 = (1.0 - 4.0*(myPhaseF - pfavg)*(myPhaseF - pfavg))/W;

	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, U, V, mag);
		F_phi[i] = calcF_phi(i, tmp1, nx, ny);
		h[i] = myPhaseF * Gamma[i] - 0.5*F_phi[i];   // heq
		g[i] = Gamma[i] - wf[i]; 				     //geq
	}
	
	#ifdef OPTIONS_Outflow
		if ((NodeType & NODE_BOUNDARY) == NODE_Convective_E || (NodeType & NODE_BOUNDARY) == NODE_Convective_N){
			<?R if (Options$Outflow){
				C(g_old, g)	
				C(h_old, h)	}	?>
		}
	#endif
	PhaseF = <?R C(sum(h)) ?>;
}

//	ITERATION:
CudaDeviceFunction void BC_Switcher ()
{
	switch (NodeType & NODE_BOUNDARY) {
		case NODE_Solid:
		case NODE_Wall:
			BounceBack();
			break;
		case NODE_MovingWall_N:
			MovingWall_N_Dirichlet();
			break;
		case NODE_MovingWall_S:
			MovingWall_S_Dirichlet();
			break;
		case NODE_NVelocity:
			NVelocity();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;

	#ifdef OPTIONS_Outflow
		case NODE_Convective_E:
			EConvective();
			break;
		case NODE_Convective_N:
			NConvective();
			break;
		case NODE_Neumann_E:
			ENeumann();
			break;
	#endif
	}

	switch (NodeType & NODE_ADDITIONALS_PF) {
		case NODE_DirichletPFEQ: 		
			PF_Dirichlet_EQ();
			break;
	}
}

CudaDeviceFunction void calcHydroIter() {
	if ((NodeType & NODE_ADDITIONALS) == NODE_Smoothing){
		Init_distributions();
	}
	else{
		poro0 = poro0; //rewrite buffer
		// omega_phi = omega_phi; //
		IB_permability = IB_permability;  //rewrite buffer
		PhaseF = PhaseF(0,0);
		real_t myPhaseF = PhaseF;
		real_t rho = calcRho(myPhaseF);
		#ifdef OPTIONS_debug	
			AddToMomentumX(U*rho);
			AddToMomentumY(V*rho);
		#endif

		BC_Switcher();		

        if (PhaseF <= 0.5) {
			AddToSumPhiGas( (1 - PhaseF) );
		}

		if (NodeType & NODE_CM) { CollisionCM();}

		myPhaseF = PhaseF(0,0);
		rho = calcRho(myPhaseF);
	
		#ifdef OPTIONS_debug
			AddToMomentumX_afterCol(U*rho);
			AddToMomentumY_afterCol(V*rho);
		#endif
	}
}


CudaDeviceFunction void calcPhaseFIter(){	
	BC_Switcher(); 
	// eq 12 from "Improved locality of the phase-field lattice Boltzmann 
	// model for immiscible fluids at high density ratios"	
	PhaseF = <?R C(sum(h)) ?>;
}

CudaDeviceFunction void calcWallPhaseIter(){
// Contact angle is defined with respect to the high density fluid
	PhaseF = PhaseF(0,0);

	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) {
		if (nw_x == 0 && nw_y == 0) { 
			PhaseF = 0.0; // TODO: why not simply PhaseF = PhaseF(0,0);
			return;
		} 
		real_t myA, myH, myPhase;

		myPhase = PhaseF_dyn(nw_x, nw_y);
		myH = sqrt(nw_x*nw_x + nw_y*nw_y );

		if (fabs(radAngle - PI/2) < 1e-4) { PhaseF = myPhase; } 
		else {   
			myA = 1.0 - 0.5*myH * (4.0/W)  * cos( radAngle );
			PhaseF = (myA - sqrt( myA*myA - 4.0 * (myA-1.0)*myPhase))/(myA-1.0) - myPhase;
		}
	} 	 
}


CudaDeviceFunction void relax_CM_hydro(real_t f_in[9], real_t tau, vector_t u)
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	
	real_t s_v = 1./tau;
	real_t s_b = omega_bulk;
	
	real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];
	
	real_t temp[9]; real_t cm_eq[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = f_in[i];}
	
	//raw moments from density-probability functions
	//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
	f_in[0] = m00;
	f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	f_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	f_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	f_in[8] = temp[5] + temp[6] + temp[7] + temp[8];
	
	//central moments from raw moments
	temp[0] = f_in[0];
	temp[1] = -f_in[0]*u.x + f_in[1];
	temp[2] = -f_in[0]*u.y + f_in[2];
	temp[3] = f_in[0]*ux2 - 2*f_in[1]*u.x + f_in[3];
	temp[4] = f_in[0]*uy2 - 2*f_in[2]*u.y + f_in[4];
	temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];
	temp[6] = -f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 - f_in[3]*u.y - 2*f_in[5]*u.x + f_in[6];
	temp[7] = -f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy - f_in[4]*u.x - 2*f_in[5]*u.y + f_in[7];
	temp[8] = f_in[0]*ux2*uy2 - 2*f_in[1]*u.x*uy2 - 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy - 2*f_in[6]*u.y - 2*f_in[7]*u.x + f_in[8];
	
	//collision in central moments space
	//calculate equilibrium distributions in cm space
	cm_eq[0] = m00;
	cm_eq[1] = -u.x*(m00 - 1.0);
	cm_eq[2] = -u.y*(m00 - 1.0);
	cm_eq[3] = m00*ux2 + 1./3.*m00 - ux2;
	cm_eq[4] = m00*uy2 + 1./3.*m00 - uy2;
	cm_eq[5] = uxuy*(m00 - 1.0);
	cm_eq[6] = -u.y*(m00*ux2 + 1./3.*m00 - ux2 - 1./3.);
	cm_eq[7] = -u.x*(m00*uy2 + 1./3.*m00 - uy2 - 1./3.);
	cm_eq[8] = m00*ux2*uy2 + 1./3.*m00*ux2 + 1./3.*m00*uy2 + 1./9.*m00 - ux2*uy2 - 1./3.*ux2 - 1./3.*uy2;
	//collide eq: -S*(cm - cm_eq)
	f_in[0] = cm_eq[0] - temp[0];
	f_in[1] = cm_eq[1] - temp[1];
	f_in[2] = cm_eq[2] - temp[2];
	f_in[3] = 0.5*(cm_eq[3] - temp[3])*(s_b + s_v) + 0.5*(cm_eq[4] - temp[4])*(s_b - s_v);
	f_in[4] = 0.5*(cm_eq[3] - temp[3])*(s_b - s_v) + 0.5*(cm_eq[4] - temp[4])*(s_b + s_v);
	f_in[5] = s_v*(cm_eq[5] - temp[5]);
	f_in[6] = cm_eq[6] - temp[6];
	f_in[7] = cm_eq[7] - temp[7];
	f_in[8] = cm_eq[8] - temp[8];
	
	//back to raw moments
	temp[0] = f_in[0];
	temp[1] = f_in[0]*u.x + f_in[1];
	temp[2] = f_in[0]*u.y + f_in[2];
	temp[3] = f_in[0]*ux2 + 2*f_in[1]*u.x + f_in[3];
	temp[4] = f_in[0]*uy2 + 2*f_in[2]*u.y + f_in[4];
	temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
	temp[6] = f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2*f_in[5]*u.x + f_in[6];
	temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy + f_in[4]*u.x + 2*f_in[5]*u.y + f_in[7];
	temp[8] = f_in[0]*ux2*uy2 + 2*f_in[1]*u.x*uy2 + 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy + 2*f_in[6]*u.y + 2*f_in[7]*u.x + f_in[8];
	
	//back to density-probability functions
	f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	f_in[1] = temp[1]/2 + temp[3]/2 - temp[7]/2 - temp[8]/2;
	f_in[2] = temp[2]/2 + temp[4]/2 - temp[6]/2 - temp[8]/2;
	f_in[3] = -temp[1]/2 + temp[3]/2 + temp[7]/2 - temp[8]/2;
	f_in[4] = -temp[2]/2 + temp[4]/2 + temp[6]/2 - temp[8]/2;
	f_in[5] = temp[5]/4 + temp[6]/4 + temp[7]/4 + temp[8]/4;
	f_in[6] = -temp[5]/4 + temp[6]/4 - temp[7]/4 + temp[8]/4;
	f_in[7] = temp[5]/4 - temp[6]/4 - temp[7]/4 + temp[8]/4;
	f_in[8] = -temp[5]/4 - temp[6]/4 + temp[7]/4 + temp[8]/4;
}

CudaDeviceFunction void relax_and_collide_CM_hydro(real_t f_in[9], real_t tau, vector_t u, vector_t Fhydro, real_t rho) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t s_v = 1./tau;
	real_t s_b = omega_bulk;
	real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];
	real_t temp[9]; real_t cm_eq[9];
	for (int i = 0; i < 9; i++) {
		temp[i] = f_in[i];}
	//raw moments from density-probability functions
	//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
	f_in[0] = m00;
	f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	//central moments from raw moments
	temp[3] = f_in[0]*ux2 - 2.0*f_in[1]*u.x + f_in[3];
	temp[4] = f_in[0]*uy2 - 2.0*f_in[2]*u.y + f_in[4];
	temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];	
	//collision in central moments space
	//calculate equilibrium distributions in cm space
	cm_eq[0] = m00;
	cm_eq[1] = -u.x*(m00 - 1.0);
	cm_eq[2] = -u.y*(m00 - 1.0);
	cm_eq[3] = m00*ux2 + 1./3.*m00 - ux2;
	cm_eq[4] = m00*uy2 + 1./3.*m00 - uy2;
	cm_eq[5] = uxuy*(m00 - 1.0);
	cm_eq[6] = -u.y*(m00*ux2 + 1./3.*m00 - ux2 - 1./3.);
	cm_eq[7] = -u.x*(m00*uy2 + 1./3.*m00 - uy2 - 1./3.);
	cm_eq[8] = m00*ux2*uy2 + 1./3.*m00*ux2 + 1./3.*m00*uy2 + 1./9.*m00 - ux2*uy2 - 1./3.*ux2 - 1./3.*uy2;

	//calculate forces in cm space
	//He et al. scheme: get_continuous_Maxwellian_DF(dzeta=dzeta, psi=1, u=(ux, uy)) - velocity term
	//collide eq: (eye(9)-S)*cm + S*cm_eq + (eye(9)-S/2.)*force_in_cm_space // SOI
	f_in[0] = cm_eq[0];
	f_in[1] = 0.5*Fhydro.x/rho + cm_eq[1];
	f_in[2] = 0.5*Fhydro.y/rho + cm_eq[2];
	f_in[3] = 0.5*cm_eq[3]*(s_b + s_v) + 0.5*cm_eq[4]*(s_b - s_v) - temp[3]*(0.5*s_b + 0.5*s_v - 1.0) - 0.5*temp[4]*(s_b - s_v);
	f_in[4] = 0.5*cm_eq[3]*(s_b - s_v) + 0.5*cm_eq[4]*(s_b + s_v) - 0.5*temp[3]*(s_b - s_v) - temp[4]*(0.5*s_b + 0.5*s_v - 1.0);
	f_in[5] = cm_eq[5]*s_v - temp[5]*(s_v - 1.0);
	f_in[6] = 1./6.*Fhydro.y/rho + cm_eq[6];
	f_in[7] = 1./6.*Fhydro.x/rho + cm_eq[7];
	f_in[8] = cm_eq[8];

	//back to raw moments
	temp[0] = f_in[0];
	temp[1] = f_in[0]*u.x + f_in[1];
	temp[2] = f_in[0]*u.y + f_in[2];
	temp[3] = f_in[0]*ux2 + 2.0*f_in[1]*u.x + f_in[3];
	temp[4] = f_in[0]*uy2 + 2.0*f_in[2]*u.y + f_in[4];
	temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
	temp[6] = f_in[0]*ux2*u.y + 2.0*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2.0*f_in[5]*u.x + f_in[6];
	temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2.0*f_in[2]*uxuy + f_in[4]*u.x + 2.0*f_in[5]*u.y + f_in[7];
	temp[8] = f_in[0]*ux2*uy2 + 2.0*f_in[1]*u.x*uy2 + 2.0*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4.0*f_in[5]*uxuy + 2.0*f_in[6]*u.y + 2.0*f_in[7]*u.x + f_in[8];
	//back to density-probability functions
	f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	f_in[1] = 0.5*temp[1] + 0.5*temp[3] - 0.5*temp[7] - 0.5*temp[8];
	f_in[2] = 0.5*temp[2] + 0.5*temp[4] - 0.5*temp[6] - 0.5*temp[8];
	f_in[3] = -0.5*temp[1] + 0.5*temp[3] + 0.5*temp[7] - 0.5*temp[8];
	f_in[4] = -0.5*temp[2] + 0.5*temp[4] + 0.5*temp[6] - 0.5*temp[8];
	f_in[5] = 0.25*temp[5] + 0.25*temp[6] + 0.25*temp[7] + 0.25*temp[8];
	f_in[6] = -0.25*temp[5] + 0.25*temp[6] - 0.25*temp[7] + 0.25*temp[8];
	f_in[7] = 0.25*temp[5] - 0.25*temp[6] - 0.25*temp[7] + 0.25*temp[8];
	f_in[8] = -0.25*temp[5] - 0.25*temp[6] + 0.25*temp[7] + 0.25*temp[8];
}

CudaDeviceFunction void relax_and_collide_CM_phase_field(real_t f_in[9], real_t tau, vector_t u, vector_t F_phi, real_t rho) 
{
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t s_v = 1./tau;

	real_t m00 = f_in[0] + f_in[1] + f_in[2] + f_in[3] + f_in[4] + f_in[5] + f_in[6] + f_in[7] + f_in[8];

	real_t temp[9];

	for (int i = 0; i < 9; i++) {
		temp[i] = f_in[i];}

	//raw moments from density-probability functions
	//[m00, m10, m01, m20, m02, m11, m21, m12, m22]
	f_in[0] = m00;
	f_in[1] = temp[1] - temp[3] + temp[5] - temp[6] - temp[7] + temp[8];
	f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];

	// f_in[2] = temp[2] - temp[4] + temp[5] + temp[6] - temp[7] - temp[8];
	// f_in[3] = temp[1] + temp[3] + temp[5] + temp[6] + temp[7] + temp[8];
	// f_in[4] = temp[2] + temp[4] + temp[5] + temp[6] + temp[7] + temp[8];
	// f_in[5] = temp[5] - temp[6] + temp[7] - temp[8];
	// f_in[6] = temp[5] + temp[6] - temp[7] - temp[8];
	// f_in[7] = temp[5] - temp[6] - temp[7] + temp[8];
	// f_in[8] = temp[5] + temp[6] + temp[7] + temp[8];

	// Central moments from raw moments
	// temp[0] = m00;
	temp[1] = -f_in[0]*u.x + f_in[1];
	temp[2] = -f_in[0]*u.y + f_in[2];

	// temp[3] = f_in[0]*ux2 - 2*f_in[1]*u.x + f_in[3];
	// temp[4] = f_in[0]*uy2 - 2*f_in[2]*u.y + f_in[4];
	// temp[5] = f_in[0]*uxuy - f_in[1]*u.y - f_in[2]*u.x + f_in[5];
	// temp[6] = -f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 - f_in[3]*u.y - 2*f_in[5]*u.x + f_in[6];
	// temp[7] = -f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy - f_in[4]*u.x - 2*f_in[5]*u.y + f_in[7];
	// temp[8] = f_in[0]*ux2*uy2 - 2*f_in[1]*u.x*uy2 - 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy - 2*f_in[6]*u.y - 2*f_in[7]*u.x + f_in[8];

	// Collision in central moments space
	// Default is second order integration (trapezoidal discretization)
	// collide eq: (eye(9)-S)*cm + S*cm_eq + (eye(9)-S/2.)*F_phi_cm
	// relax 1st moments
	f_in[0] = m00;
	f_in[1] = -F_phi.x*(0.5*s_v - 1.0) - temp[1]*(s_v - 1.0);
	f_in[2] = -F_phi.y*(0.5*s_v - 1.0) - temp[2]*(s_v - 1.0);
	f_in[3] = 1./3.*m00;
	f_in[4] = 1./3.*m00;
	f_in[5] = 0;
	f_in[6] = 1./6.*F_phi.y;
	f_in[7] = 1./6.*F_phi.x;
	f_in[8] = 1./9.*m00;

	//back to raw moments
	temp[0] = f_in[0];
	temp[1] = f_in[0]*u.x + f_in[1];
	temp[2] = f_in[0]*u.y + f_in[2];
	temp[3] = f_in[0]*ux2 + 2*f_in[1]*u.x + f_in[3];
	temp[4] = f_in[0]*uy2 + 2*f_in[2]*u.y + f_in[4];
	temp[5] = f_in[0]*uxuy + f_in[1]*u.y + f_in[2]*u.x + f_in[5];
	temp[6] = f_in[0]*ux2*u.y + 2*f_in[1]*uxuy + f_in[2]*ux2 + f_in[3]*u.y + 2*f_in[5]*u.x + f_in[6];
	temp[7] = f_in[0]*u.x*uy2 + f_in[1]*uy2 + 2*f_in[2]*uxuy + f_in[4]*u.x + 2*f_in[5]*u.y + f_in[7];
	temp[8] = f_in[0]*ux2*uy2 + 2*f_in[1]*u.x*uy2 + 2*f_in[2]*ux2*u.y + f_in[3]*uy2 + f_in[4]*ux2 + 4*f_in[5]*uxuy + 2*f_in[6]*u.y + 2*f_in[7]*u.x + f_in[8];

	//back to density-probability functions
	f_in[0] = temp[0] - temp[3] - temp[4] + temp[8];
	f_in[1] = temp[1]/2 + temp[3]/2 - temp[7]/2 - temp[8]/2;
	f_in[2] = temp[2]/2 + temp[4]/2 - temp[6]/2 - temp[8]/2;
	f_in[3] = -temp[1]/2 + temp[3]/2 + temp[7]/2 - temp[8]/2;
	f_in[4] = -temp[2]/2 + temp[4]/2 + temp[6]/2 - temp[8]/2;
	f_in[5] = temp[5]/4 + temp[6]/4 + temp[7]/4 + temp[8]/4;
	f_in[6] = -temp[5]/4 + temp[6]/4 - temp[7]/4 + temp[8]/4;
	f_in[7] = temp[5]/4 - temp[6]/4 - temp[7]/4 + temp[8]/4;
	f_in[8] = -temp[5]/4 - temp[6]/4 + temp[7]/4 + temp[8]/4;
}

CudaDeviceFunction real_t getPermability()
{
	// Darcy Forcing
	// The Kozeny-Carman equation provides a way to estimate the permeability of a porous medium based on its porosity and specific surface area.
	real_t Kazeny_coeff = 1.;
	real_t ssa = 1. ; // the specific surface area (surface area per unit volume of solid).

	real_t permability = poro0*poro0*poro0; 
	permability /= (Kazeny_coeff*(1-poro0)*(1-poro0)+1E-3);
	permability /= (ssa*ssa);

	return permability;
}

CudaDeviceFunction vector_t calcTotalHydrodynamicForceCM(vector_t gradPhi, real_t rho, real_t tau, real_t mu, real_t p)
{
	// arguments:
	// gradPhi - Phase field gradients
	// Fluid Properties: //
	// real_t rho - fluid density
	// real_t tau - relaxation parameter
	// real_t mu - chemical potential 
	// real_t p - normalized pressure

	real_t Gamma[9], geq[9], mag;	// equilibrium, pressure equilibrium, velocity magnitude
	real_t F_pressure[2], F_body[2], F_mu[2], F_surf_tension[2], F_Darcy[2], F_IB[2];   // Forces
	F_Darcy[0] = 0;
	F_Darcy[1] = 0;
	vector_t F_total_hydro;	

	real_t stress[3];				// Stress tensor calculation
	real_t R[9];				// Populations for relaxation

	// Force Calculations
	// eq 19
	real_t density_coeff = (Density_h-Density_l)/(PhaseField_h-PhaseField_l);
	F_pressure[0] = (-1.0/3.0) * p * density_coeff * gradPhi.x;
	F_pressure[1] = (-1.0/3.0) * p * density_coeff * gradPhi.y;	

	F_body[0] = -1.0*(rho-Density_l)*BuoyancyX + rho*GravitationX;
	F_body[1] = -1.0*(rho-Density_l)*BuoyancyY + rho*GravitationY;
	
	// eq 4
	F_surf_tension[0] = mu*gradPhi.x;
	F_surf_tension[1] = mu*gradPhi.y;
	

	// Calculate viscous force
	for (int j=0;j<fixedIterator;j++){
		// User has the choice in attempt to improve stability to use
		// a fixed point iteration style update for the viscous force.
		for (int i=0; i< 9; i++){
			R[i] = g[i];
		}
		
		vector_t u;
		u.x = U;
		u.y = V;
		relax_CM_hydro(R, tau, u); 

		// Stress/strain Tensor
		stress[0] = 0.0;stress[1] = 0.0;stress[2] = 0.0;
		for (int i=0; i< 9; i++){
			stress[0] -= R[i]*d2q9_ex[i]*d2q9_ex[i];
			stress[1] -= R[i]*d2q9_ex[i]*d2q9_ey[i];
			stress[2] -= R[i]*d2q9_ey[i]*d2q9_ey[i];    
		}
		
		// Viscous force
		F_mu[0] = (0.5-tau) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y) * density_coeff;
		F_mu[1] = (0.5-tau) * (stress[1]*gradPhi.x + stress[2]*gradPhi.y) * density_coeff;
		
		// Total Hydrodynamic Force
		F_total_hydro.x = F_surf_tension[0] + F_pressure[0] + F_body[0] + F_mu[0] + F_Darcy[0];
		F_total_hydro.y = F_surf_tension[1] + F_pressure[1] + F_body[1] + F_mu[1] + F_Darcy[1];
		F_total_hydro.z = 0;

		// update velocity and re-iterate
		U = g[1]-g[3]+g[5]-g[6]-g[7]+g[8];
		V = g[2]-g[4]+g[5]+g[6]-g[7]-g[8];
		
		U += 0.5*F_total_hydro.x/rho;
		V += 0.5*F_total_hydro.y/rho;


		// Darcy Forcing
		
		real_t permability = getPermability();

		real_t kin_visc = (tau-0.5)/3.;
		real_t dyn_visc = kin_visc*rho; // calcDynVisc
		real_t coeff_darcy = 2*dyn_visc/(2*rho*permability+dyn_visc);
		
		F_Darcy[0] = -rho*U*coeff_darcy;
		F_Darcy[1] = -rho*V*coeff_darcy;
		// F_Darcy[0] = 0;
		// F_Darcy[1] = 0;
		U += 0.5*F_Darcy[0]/rho;
		V += 0.5*F_Darcy[1]/rho;
		F_total_hydro.x += F_Darcy[0];
		F_total_hydro.y += F_Darcy[1];

		// add the immersed boundary to stop the fluid
		real_t u_IB[2]; u_IB[0]=0.; u_IB[1]=0;  // impose 0 as the velocity at IB points 
		F_IB[0] = (1-IB_permability) * 2*rho*(u_IB[0] - U);
		F_IB[1] = (1-IB_permability) * 2*rho*(u_IB[1] - V);

		U +=  0.5*F_IB[0]/rho;
		V +=  0.5*F_IB[1]/rho;

		F_total_hydro.x += F_IB[0];
		F_total_hydro.y += F_IB[1];
	}

	#ifdef OPTIONS_debug
		AddToF_pressureX(F_pressure[0]);
		AddToF_pressureY(F_pressure[1]);
		AddToF_bodyX(F_body[0]);
		AddToF_bodyY(F_body[1]);
		AddToF_surf_tensionX(F_surf_tension[0]);
		AddToF_surf_tensionY(F_surf_tension[1]);
		AddToF_muX(F_mu[0]);
		AddToF_muY(F_mu[1]);
		AddToF_DarcyX(F_Darcy[0]);
		AddToF_DarcyY(F_Darcy[1]);
		AddToF_total_hydroX(F_total_hydro.x);
		AddToF_total_hydroY(F_total_hydro.y);
	#endif

	return F_total_hydro;
}

CudaDeviceFunction void CollisionCM(){
	real_t myPhaseF = PhaseF(0,0);

	// Find Macroscopic Details
	real_t rho = calcRho(myPhaseF);
	real_t tau = calcTau(myPhaseF, rho);
	real_t pfavg = 0.5*(PhaseField_l+PhaseField_h);

	// Gradients & Normals
	vector_t gradPhi = calcGradPhi(); // Phase field gradient
	real_t p = getNormalizedPressure(); // normalized pressure

	vector_t Fhydro = calcTotalHydrodynamicForceCM(gradPhi, rho, tau,  calcMu(myPhaseF), p);

	// PHASE FIELD POPULATION UPDATE:
	vector_t u; u.x = U; u.y = V;
	vector_t F_phi_vect = calcF_phi_xy(gradPhi,  myPhaseF,  pfavg);
	#ifdef OPTIONS_debug
		AddToF_phiX(F_phi_vect.x);
		AddToF_phiY(F_phi_vect.y);
	#endif
	relax_and_collide_CM_phase_field(h, 1./omega_phi, u, F_phi_vect, rho);
	
	// PRESSURE EVOLUTION UPDATE:
	relax_and_collide_CM_hydro(g, tau, u, Fhydro, rho);
}

//	MISCELLANIOUS FUNCTIONS:
CudaDeviceFunction float2 Color() {
        float2 ret;
        //vector_t u = getU();
		//ret.x = sqrt(u.x*u.x + u.y*u.y);
		
        if (PhaseF(0,0) < 0.8){
                ret.y = 0;
        } else {
                ret.y = 1;
		}
		
		ret.x = sqrt(U*U+V*V);
		//ret.y =1;
        return ret;
}


//	BOUNDARY CONDITIONS:
#ifdef OPTIONS_Outflow
	CudaDeviceFunction void EConvective()
	{
		real_t U_local = U(-1,0);
		real_t invU = 1.0 / (1 + U_local) ;
		<?R if (Options$Outflow){
			C(g, (g_old + U_loc*g_n)*U_inv)
			C(h, (h_old + U_loc*h_n)*U_inv)

			C(g_old,g)
			C(h_old,h)}
		?>

	}

	CudaDeviceFunction void NConvective()
	{
		real_t U_local = V(0,-1);
		real_t invU = 1.0 / (1 + U_local) ;
		<?R if (Options$Outflow){
			C(g, (g_old + U_loc*g_n1)*U_inv)
			C(h, (h_old + U_loc*h_n1)*U_inv)

			C(g_old,g)
			C(h_old,h)}
		?>

	}

	CudaDeviceFunction void ENeumann()
	{
		// Set the values at the boundary nodes to those of the post-stream inside node 
		//	As a result of this we need to manually stream to values here.
		<?R if (Options$Outflow) {
		C(g, PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],")",sep="")))
		C(h, PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],")",sep="")))
		} ?>

	}
#endif

CudaDeviceFunction void WVelocity()
{
	/********* velocity-type Zou He boundary condition with force - hydrodynamics ****************/
	PhaseF = PhaseField_init; 
	vector_t gradPhi = calcGradPhi(); // Phase field gradient
	real_t rho = calcRho(PhaseF);
	real_t tau = calcTau(PhaseF, rho);
	real_t p = getNormalizedPressure() ; // normalized pressure
	vector_t Fhydro;
	if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, rho, tau,  calcMu(PhaseF), p);}


	// enforce Poiseuille velocity profile
	// real_t R = (pipe_diameter / 2) - 2; // subtract top/bottom wall thickness
	// real_t uInProfileX = VelocityX *(2 * Y* R - Y*Y) / (R*R); // calculate profile
	
	// Appendix C16-C23 from
	// "Phase-field-based lattice Boltzmann model for incompressible binary fluid systems
	// with density and viscosity contrasts" by Y. Q. Zu and S. He, 2013
	real_t F_i[9], g_prim[9];
	for (int i=0; i< 9; i++){
			// eq 15 from "Improved locality of the phase-field lattice Boltzmann 
			//	model for immiscible fluids at high density ratios"
			F_i[i] = 3.0*wf[i] * (Fhydro.x*d2q9_ex[i] + Fhydro.y*d2q9_ey[i])/rho; // eq 15
			g_prim[i] = g[i] + 0.5 * F_i[i]; // eq C6 		
	}
	
	real_t Gamma[9], heq[9], geq[9];
	real_t mag = VelocityX*VelocityX + VelocityY*VelocityY; // velocity magnitude
	
	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, VelocityX, VelocityY, mag);	 
		geq[i] = wf[i]*p + Gamma[i] - wf[i]; // eq 17
		heq[i] = PhaseF * Gamma[i];  // eq 10
	}

	// Excess of momentum (positive value upwards)
	real_t N = 2; // number of unknown distributions: e[i] * n_tau !=0
	real_t M = d2q9_ey[2]*(g_prim[2] - geq[2]) + d2q9_ey[4]*(g_prim[4] - geq[4]); // eq C18

	g[1] = -0.5*F_i[1] + g_prim[3] + geq[1] - geq[3] ; // eq C17
	g[5] = -0.5*F_i[5] + g_prim[7] + geq[5] - geq[7] - d2q9_ey[5] * M / N; // eq C19
	g[8] = -0.5*F_i[8] + g_prim[6] + geq[8] - geq[6] - d2q9_ey[8] * M / N; // eq C19

	/*********  Zou He boundary condition with force - phaseField ****************/
	
	// excess density - eq C22 from 
	// "Phase-field-based lattice Boltzmann model for incompressible binary fluid systems
	// with density and viscosity contrasts" by Y. Q. Zu and S. He, 2013
	real_t v = h[4] - heq[4] + h[2] - heq[2];

	h[1] = heq[1] - (h[3]-heq[3]); 		   // eq C23a 
	h[8] = heq[8] - (h[6]-heq[6]) - v/N;   // eq C23b
	h[5] = heq[5] - (h[7]-heq[7]) - v/N;   // eq C23b

	// IF SOMEONE WANTS TO INVESTIGATE BOUNDARY CONDITIONS:
		// eq 6.58 p253 from The Lattice Boltzmann Method: Principles and Practice - rotated 90deg
		// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
		// NOTE THAT THIS IS A VELOCITY BASED LBM SO FORMULAS ARE MODIFIED

			// g[1] = g[3] + 2./3.*VelocityX - Fhydro.x/6.;
			// g[5] = g[7] + (1./2.)*(g[4] - g[2]) + VelocityY/2. + VelocityX/6. - Fhydro.y/4. - Fhydro.x/6.;
			// g[8] = g[6] + (1./2.)*(g[2] - g[4]) - VelocityY/2. + VelocityX/6. + Fhydro.y/4. - Fhydro.x/6.;
			
			// TODO: cant see difference, it seems that Fhydro = 0
		// TODO: eq C23 work only for inlet; for moving wall use 'standard' bounce back, as one below

			// h[1] = h[3]; 		  
			// h[8] = h[6];
			// h[5] = h[7];
}

CudaDeviceFunction void NVelocity()
{	
	/********* velocity-type Zou He boundary condition with force - hydrodynamics ****************/

	PhaseF = PhaseField_init; 

	vector_t gradPhi = calcGradPhi(); // Phase field gradient
	real_t rho = calcRho(PhaseF);
	real_t tau = calcTau(PhaseF, rho);
	real_t p = getNormalizedPressure() ; // normalized pressure
	vector_t Fhydro;

	if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, rho, tau,  calcMu(PhaseF), p);}


	// Appendix C16-C23 from
	// "Phase-field-based lattice Boltzmann model for incompressible binary fluid systems
	// with density and viscosity contrasts" by Y. Q. Zu and S. He, 2013
	real_t F_i[9], g_prim[9];
	for (int i=0; i< 9; i++){
			// eq 15 from "Improved locality of the phase-field lattice Boltzmann 
			//	model for immiscible fluids at high density ratios"
			F_i[i] = 3.0*wf[i] * (Fhydro.x*d2q9_ex[i] + Fhydro.y*d2q9_ey[i])/rho; // eq 15
			g_prim[i] = g[i] + 0.5 * F_i[i]; // eq C6 		
	}
	
	real_t Gamma[9], heq[9], geq[9];
	real_t mag = VelocityX*VelocityX + VelocityY*VelocityY; // velocity magnitude
	
	for (int i=0; i< 9; i++){
		Gamma[i] = calcGamma(i, VelocityX, VelocityY, mag);	 
		geq[i] = wf[i]*p + Gamma[i] - wf[i]; // eq 17
		heq[i] = PhaseF * Gamma[i];  // eq 10
	}

	// Excess of momentum (positive value upwards)
	real_t N = 2; // number of unknown distributions: e[i] * n_tau !=0
	real_t M = d2q9_ey[3]*(g_prim[3] - geq[3]) + d2q9_ey[1]*(g_prim[1] - geq[1]); // eq C18

	g[4] = -0.5*F_i[3] + g_prim[2] + geq[4] - geq[2] ; // eq C17
	g[7] = -0.5*F_i[7] + g_prim[5] + geq[7] - geq[5] - d2q9_ey[7] * M / N; // eq C19
	g[8] = -0.5*F_i[8] + g_prim[6] + geq[8] - geq[6] - d2q9_ey[8] * M / N; // eq C19

	/*********  Zou He boundary condition with force - phaseField ****************/
	
	// excess density - eq C22 from 
	// "Phase-field-based lattice Boltzmann model for incompressible binary fluid systems
	// with density and viscosity contrasts" by Y. Q. Zu and S. He, 2013
	real_t v = h[3] - heq[3] + h[1] - heq[1];

	// h[4] = heq[4] - (h[2]-heq[2]); 			// eq C23a
	// h[7] = heq[7] - (h[5]-heq[5]) - v*0.5;   // eq C23b
	// h[8] = heq[8] - (h[6]-heq[6]) - v*0.5;   // eq C23b

	// TODO: eq C23 work only for inlet; for moving wall use 'standard' bounce back, as one below
	h[4] = h[2];
	h[7] = h[5];
	h[8] = h[6];

	real_t dJ = <?R C(g[5+1]*d2q9[5+1,1] + g[6+1]*d2q9[6+1,1])?> * rho + 0.5*Fhydro.x; // incoming momentum - before collision
	AddToNMovingWallForce( -dJ ); 
	AddToNMovingWallPower( -VelocityX * dJ );
	//IF SOMEONE WANTS TO INVESTIGATE BOUNDARY CONDITIONS
		// <?R C(g[5+1]*d2q9[5+1,1] + g[6+1]*d2q9[6+1,1])?>;	--compiles to--> 	-g[6] + g[5];
			// eq 6.58 p253 from The Lattice Boltzmann Method: Principles and Practice
		// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
		// NOTE THAT THIS IS A VELOCITY BASED LBM SO FORMULAS ARE MODIFIED
		// Fhydro.x=0; // TODO: cant see much difference
		// Fhydro.y=0;

		// g[4] = g[2] -2./3.*VelocityY + Fhydro.y/6.;
		// g[7] = g[5] + (1./2.)*(g[1] - g[3]) - VelocityX/2.0 - VelocityY/6.0 + Fhydro.x/4.0 + Fhydro.y/6.0;
		// g[8] = g[6] + (1./2.)*(g[3] - g[1]) + VelocityX/2.0 - VelocityY/6.0 - Fhydro.x/4.0 + Fhydro.y/6.0;
}

CudaDeviceFunction void MovingWall_S_Dirichlet(){
	// The bounce-back formula for a Dirichlet boundary condition with a prescribed wall velocity
	// eq 5.26 p180 from The Lattice Boltzmann Method: Principles and Practice
	// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	// TODO: IMPLEMENT ACTUAL BOUNDARY CONDITION
	g[2] = g[4];
	g[5] = g[7] + VelocityX/6.0;
	g[6] = g[8] - VelocityX/6.0;

	h[2] = h[4];
	h[5] = h[7];
	h[6] = h[8];
}

CudaDeviceFunction void MovingWall_N_Dirichlet(){
	// The bounce-back formula for a Dirichlet boundary condition with a prescribed wall velocity
	// eq 5.26 p180 from The Lattice Boltzmann Method: Principles and Practice
	// T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	// TODO: IMPLEMENT ACTUAL BOUNDARY CONDITION
	g[4] = g[2];
	g[7] = g[5] - VelocityX/6.0;
	g[8] = g[6] + VelocityX/6.0;

	h[4] = h[2];
	h[7] = h[5];
	h[8] = h[6];
}

CudaDeviceFunction void BounceBack()
{
	vector_t p1,p2;
	if((NodeType & NODE_BODY) == NODE_Body) {
		p1.x = g[8] +g[1] +g[5] -g[6] -g[3] -g[7];
		p1.y = g[5] +g[2] +g[6] -g[7] -g[4] -g[8];

		vector_t gradPhi = calcGradPhi(); // Phase field gradient
		real_t rho = calcRho(PhaseF);
		real_t tau = calcTau(PhaseF, rho);
		real_t p = getNormalizedPressure() ; // normalized pressure
		vector_t Fhydro;
		if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, rho, tau,  calcMu(PhaseF), p);}
		p1.x = p1.x*rho + 0.5*Fhydro.x;
		p1.y = p1.y*rho + 0.5*Fhydro.y;
	}

	real_t tmp;
	tmp = g[1];
	g[1] = g[3];
	g[3] = tmp;
	tmp = g[2];
	g[2] = g[4];
	g[4] = tmp;
	tmp = g[5];
	g[5] = g[7];
	g[7] = tmp;
	tmp = g[6];
	g[6] = g[8];
	g[8] = tmp;

	tmp = h[1];
	h[1] = h[3];
	h[3] = tmp;
	tmp = h[2];
	h[2] = h[4];
	h[4] = tmp;
	tmp = h[5];
	h[5] = h[7];
	h[7] = tmp;
	tmp = h[6];
	h[6] = h[8];
	h[8] = tmp;

	//Summing the difference in momentum before/after collision
	if((NodeType & NODE_BODY) == NODE_Body) {
		p2.x = g[8] +g[1] +g[5] -g[6] -g[3] -g[7];
		p2.y = g[5] +g[2] +g[6] -g[7] -g[4] -g[8];

		vector_t gradPhi = calcGradPhi(); // Phase field gradient
		real_t rho = calcRho(PhaseF);
		real_t tau = calcTau(PhaseF, rho);
		real_t p = getNormalizedPressure() ; // normalized pressure
		vector_t Fhydro;
	
		if (NodeType & NODE_CM) { Fhydro = calcTotalHydrodynamicForceCM(gradPhi, rho, tau,  calcMu(PhaseF), p);}

		p2.x = p2.x*rho + 0.5*Fhydro.x;
		p2.y = p2.y*rho + 0.5*Fhydro.y;

		AddToFDrag(-(p2.x-p1.x));
		AddToFLift(-(p2.y-p1.y));
		AddToFTotal(sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y)));
	}
}
