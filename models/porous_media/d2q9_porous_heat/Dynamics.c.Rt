// maintainer: Grzegorz Gruszczynski @ggruszczynski
<?R 
	source("conf.R")
    c_header();
	source("lib/lattice.R")
	source("lib/feq.R")
	source("lib/boundary.R")
    
    # Creating variables for symbolic computations
		f = PV(DensityAll$name[DensityAll$group=="f"])
		h = PV(DensityAll$name[DensityAll$group=="h"])

		rho =  PV("rho")
		u = PV(c("ux","uy","uz"))
		J = PV("J",c("x","y","z"))

		rhoT = PV("rhoT")
		tmp = PV("tmp")

    # Extracting velocity set
		U 		 = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])
		UforHeat = as.matrix(DensityAll[DensityAll$group=="h",c("dx","dy","dz")])

    # Calculating equlibrium density set
		EQ = MRT_eq(U, rho, J, ortogonal=FALSE);
		#EQ$feq = EQ$Req %*% solve(EQ$mat)

	if (Options$OutFlowNeumann) 
	{
		f_neighbours = Density$nicename[Density$group =="f"]
		h_neighbours = Density$nicename[Density$group =="h"]
	}

?>


<?RT models/porous_media/d2q9_porous_heat/VTKOutputs.c.Rt ?>


CudaDeviceFunction void Init() {
	real_t pressure = Pressure;
	vector_t u; u.x = VelocityX; u.y = VelocityY; u.z = 0;

	if((NodeType & NODE_BOUNDARY) == NODE_Wall){
		u.x = 0; u.y = 0; u.z = 0;
		pressure = 0;
	}
	
	real_t rho = InitRho*material_density + pressure * 3.0;
	real_t H = rho*cp*InitTemperature;

	SetEquilibriumHydro(rho, u.x, u.y, u.z);

	if(CylinderCenterX_GH > 0 && CylinderCenterY_GH > 0 && Sigma_GH > 0){ 
		// Gaussian Hill Benchmark
		real_t dx = X - CylinderCenterX_GH;
		real_t dy = Y - CylinderCenterY_GH;
		real_t L = dx*dx + dy*dy;
		H *= exp(-L/(2*Sigma_GH));
	}

	SetEquilibriumHeat(H,rho,u);
}



<?RT models/porous_media/d2q9_porous_heat/BoundaryConditions.c.Rt ?>

CudaDeviceFunction void RunBoundariesHydrodynamics()
{    
	switch (NodeType & NODE_BOUNDARY) {
		case NODE_RhoDirichletEQ:
			RhoDirichletEquilibriumScheme();
			break;
		case NODE_RhoSource:
			RhoSource();
			break;
		case NODE_Lid:
			LidVelocity();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;
		case NODE_EPressure:
			EPressure();
			break;
		case NODE_Wall:
			HydroBounceBack();
			ThermalBounceBack();
			break;
		#ifdef OPTIONS_OutFlowNeumann
			case NODE_ENeumann:
				ENeumann();
				break;
		#endif
	}
}


CudaDeviceFunction void RunBoundariesHeat()
{	
	real_t h1, h2;
	switch (NodeType & NODE_ADDITIONALS_HEAT) {
		case NODE_HeaterDirichletTemperatureEQ:
			h1 = <?R C(sum(h)) ?>;   		
			HeatDirichletEquilibriumScheme();
			h2 = <?R C(sum(h)) ?>;
			AddToHeatSource(h2-h1);  
			break;
		case NODE_HeaterDirichletTemperatureABB:	
			h1 = <?R C(sum(h)) ?>;   		
			HeatDirichletAntiBounceBackScheme();
			h2 = <?R C(sum(h)) ?>;
			AddToHeatSource(h2-h1);  
			break;
		case NODE_HeaterSource:
			h1 = <?R C(sum(h)) ?>;   		
			HeaterSource();
			h2 = <?R C(sum(h)) ?>;
			AddToHeatSource(h2-h1);  
			break;
		case NODE_HeaterNeumannHeatFluxCylinder:
			h1 = <?R C(sum(h)) ?>;   		
			ImposeHeatFlux(get_n_cylinder());
			h2 = <?R C(sum(h)) ?>;
			AddToHeatSource(h2-h1);
		case NODE_HeaterNeumannHeatFluxEast:
		{
			h1 = <?R C(sum(h)) ?>;   		
			vector_t n{-1.,0,0};
			ImposeHeatFlux(n);
			h2 = <?R C(sum(h)) ?>;
			AddToHeatSource(h2-h1);  
			break;
		}
	}
}


CudaDeviceFunction void Run() {
	vector_t p1 {0,0,0};
	if((NodeType & NODE_OBJECTIVEFORCE) == NODE_ForceMeasurmentZone) {
		<?R C(PV(c("p1.x","p1.y", "p1.z")), f %*% U) ?>
	}

	RunBoundariesHydrodynamics();
	RunBoundariesHeat();	

// poro0 = poro0; // TODO: do we need to overwrite the buffer here?
// 	conductivity_brush =  conductivity_brush;
    switch (NodeType & NODE_COLLISION) {    
		case NODE_CM_HIGHER:
			CollisionCM_HIGHER();
			break;
		case NODE_Cumulants:
			CollisionCumulants();
			break;
		case NODE_CM_HIGHER_PROB:
			CollisionCM_HIGHER_PROB();
			break;	
		case NODE_CM_HIGHER_PROB_M_EQ:
			CollisionCM_HIGHER_PROB_M_EQ();
			break;
	}

	if((NodeType & NODE_OBJECTIVEFORCE) == NODE_ForceMeasurmentZone) {
		vector_t p2;
		<?R C(PV(c("p2.x","p2.y", "p2.z")), f %*% U) ?>
		//Summing the difference in momentum before/after collision
		AddToFDrag(-(p2.x-p1.x));
		AddToFLift(-(p2.y-p1.y));
	}

	if((NodeType & NODE_OBJECTIVEFLUX) == NODE_FluxMeasurmentZone1) {
		vector_t p2;
		<?R C(PV(c("p2.x","p2.y", "p2.z")), f %*% U) ?>
		//Summing the momentum flux through the boundary.
		AddToXHydroFLux(-p2.x);
		AddToYHydroFLux(-p2.y);

		vector_t h2;
		<?R C(PV(c("h2.x","h2.y", "h2.z")), h %*% UforHeat) ?>
		// Summing the heat flux (both convective and diffusive) through the boundary.
		// convective flux - eq part of h distributions
		// diffusive flux - neq part of h distributions

		AddToHeatFluxX(-h2.x);
		AddToHeatFluxY(-h2.y);
	}

	if((NodeType & NODE_OBJECTIVEFLUX) == NODE_FluxMeasurmentZone2) {
		vector_t p2;
		<?R C(PV(c("p2.x","p2.y", "p2.z")), f %*% U) ?>
		//Summing the momentum flux through the boundary.
		AddToXHydroFLux2(-p2.x);
		AddToYHydroFLux2(-p2.y);

		vector_t h2;
		<?R C(PV(c("h2.x","h2.y", "h2.z")), h %*% UforHeat) ?>
		// Summing the heat flux (both convective and diffusive) through the boundary.
		// convective flux - eq part of h distributions
		// diffusive flux - neq part of h distributions

		AddToHeatFluxX2(-h2.x);
		AddToHeatFluxY2(-h2.y);
	}


}

CudaDeviceFunction vector_t get_n_cylinder()
{
	real_t dx = X - CylinderCenterX;
	real_t dy = Y - CylinderCenterY;

	real_t L = sqrt(dx*dx + dy*dy);
	vector_t n;
	n.x = dx/L;
	n.y = dy/L;
	n.z = 0;
	return n;
}

CudaDeviceFunction void SetEquilibriumHydro(real_t rho, real_t Jx, real_t Jy, real_t Jz)
{
	<?R
		C(f, EQ$Req %*% solve(EQ$mat));
	?>
}


CudaDeviceFunction void SetEquilibriumHeat(real_t H, real_t rho, vector_t u) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	#ifdef OPTIONS_CHT
		real_t Sigma2 = 1./3.*h_stability_enhancement/(cp*rho);
	#else
		real_t Sigma2 = 1./3.;
	#endif
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	//equilibrium in central moments space
	h000 = H;
	h100 = 0;
	h010 = 0;
	h200 = H*Sigma2;
	h020 = H*Sigma2;
	h110 = 0;
	h210 = 0;
	h120 = 0;
	h220 = H*Sigma2*Sigma2;
	//back to raw moments
	real_t temp000 = h000;
	real_t temp100 = h000*u.x + h100;
	real_t temp010 = h000*u.y + h010;
	real_t temp200 = h000*ux2 + 2.*h100*u.x + h200;
	real_t temp020 = h000*uy2 + 2.*h010*u.y + h020;
	real_t temp110 = h000*uxuy + h010*u.x + h100*u.y + h110;
	real_t temp210 = h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy + 2.*h110*u.x + h200*u.y + h210;
	real_t temp120 = h000*u.x*uy2 + 2.*h010*uxuy + h020*u.x + h100*uy2 + 2.*h110*u.y + h120;
	real_t temp220 = h000*ux2*uy2 + 2.*h010*ux2*u.y + h020*ux2 + 2.*h100*u.x*uy2 + 4.*h110*uxuy + 2.*h120*u.x + h200*uy2 + 2.*h210*u.y + h220;
	//back to density-probability functions
	h000 = temp000 - temp020 - temp200 + temp220;
	h100 = 1/2.*temp100 - 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h200 = -1/2.*temp100 + 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h010 = 1/2.*temp010 + 1/2.*temp020 - 1/2.*temp210 - 1/2.*temp220;
	h110 = 1/4.*temp110 + 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h210 = -1/4.*temp110 - 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h020 = -1/2.*temp010 + 1/2.*temp020 + 1/2.*temp210 - 1/2.*temp220;
	h120 = -1/4.*temp110 + 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
	h220 = 1/4.*temp110 - 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
}

CudaDeviceFunction void relax_and_collide_ADE_Cumulants(real_t rho, real_t omega_ade, vector_t u, vector_t fluxHDarcy)
{
	#ifdef OPTIONS_CHT
		real_t Sigma2 = 1/3.*h_stability_enhancement/(cp*rho);
	#else
		real_t Sigma2 = 1/3.;
	#endif
		 
	// moments from the density-probability function
	h000 = h200 + h100 + h000;
	h100 = -h200 + h100;
	h200 = h100 + h200*2.;
	h010 = h210 + h110 + h010;
	h110 = -h210 + h110;
	h210 = h110 + h210*2.;
	h020 = h220 + h120 + h020;
	h120 = -h220 + h120;
	h220 = h120 + h220*2.;
	h000 = h020 + h010 + h000;
	h010 = -h020 + h010;
	h020 = h010 + h020*2.;
	h100 = h120 + h110 + h100;
	h110 = -h120 + h110;
	h120 = h110 + h120*2.;
	h200 = h220 + h210 + h200;
	h210 = -h220 + h210;
	h220 = h210 + h220*2.;

	// from moments to cumulants
	real_t c000 = h000;
	real_t c100 = h100/h000;
	real_t c200 = ( -c100*h100 + h200 )/h000;
	real_t c010 = h010/h000;
	real_t c110 = ( -c100*h010 + h110 )/h000;
	real_t c210 = ( -c110*h100 - c200*h010 - c100*h110 + h210 )/h000;
	real_t c020 = ( -c010*h010 + h020 )/h000;
	real_t c120 = ( -c100*h020 + h120 - c110*h010*2. )/h000;
	real_t c220 = ( -c120*h100 - c200*h020 - c100*h120 + h220 + ( -c210*h010 - c110*h110 )*2. )/h000;

	// relaxation
	c100 = omega_ade*u.x + c100 * (1-omega_ade);
	c010 = omega_ade*u.y + c010 * (1-omega_ade);
	
	// porous flavour
	c100 += (1-omega_ade/2.)*fluxHDarcy.x;
	c010 += (1-omega_ade/2.)*fluxHDarcy.y;

	c200 = Sigma2;
	c020 = Sigma2;
	c110 = 0;
	c120 = (1-omega_ade)*c120;
	c210 = (1-omega_ade)*c210;
	c220 = 0;


	// from cummulants to moments
	h000 = h000;
	h100 = c100*h000;
	h200 = c200*h000 + c100*h100;
	h010 = c010*h000;
	h110 = c110*h000 + c100*h010;
	h210 = c210*h000 + c110*h100 + c200*h010 + c100*h110;
	h020 = c020*h000 + c010*h010;
	h120 = c120*h000 + c100*h020 + c110*h010*2.;
	h220 = c220*h000 + c120*h100 + c200*h020 + c100*h120 + ( c210*h010 + c110*h110 )*2.;

	// from moments to density distribution function
	h000 = -h200 + h000;
	h100 = ( h200 + h100 )/2.;
	h200 = h200 - h100;
	h010 = -h210 + h010;
	h110 = ( h210 + h110 )/2.;
	h210 = h210 - h110;
	h020 = -h220 + h020;
	h120 = ( h220 + h120 )/2.;
	h220 = h220 - h120;
	h000 = -h020 + h000;
	h010 = ( h020 + h010 )/2.;
	h020 = h020 - h010;
	h100 = -h120 + h100;
	h110 = ( h120 + h110 )/2.;
	h120 = h120 - h110;
	h200 = -h220 + h200;
	h210 = ( h220 + h210 )/2.;
	h220 = h220 - h210;
}

CudaDeviceFunction void relax_and_collide_ADE_CM_HIGHER_PROB(real_t rho, real_t omega_ade, vector_t u_hydro) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	#ifdef OPTIONS_CHT
		real_t Sigma2 = 1./3.*h_stability_enhancement/(cp*rho);
	#else
		real_t Sigma2 = 1./3.;
	#endif

	real_t H = h000 + h010 + h020 + h100 + h110 + h120 + h200 + h210 + h220;
	real_t temp000 = h000;
	real_t temp100 = h100;
	real_t temp010 = h010;
	real_t temp200 = h200;
	real_t temp020 = h020;
	real_t temp110 = h110;
	real_t temp210 = h210;
	real_t temp120 = h120;
	real_t temp220 = h220;
	//raw moments from density-probability functions
	h000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	h010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	h200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	h110 = temp110 - temp120 - temp210 + temp220;
	h210 = temp110 - temp120 + temp210 - temp220;
	h120 = temp110 + temp120 - temp210 - temp220;
	h220 = temp110 + temp120 + temp210 + temp220;

	vector_t u;
	u.x = h100/h000;
	u.y = h010/h000;
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	//central moments from raw moments
	temp000 = h000;
	temp100 = -h000*u.x + h100;
	temp010 = -h000*u.y + h010;
	temp200 = h000*ux2 - 2.*h100*u.x + h200;
	temp020 = h000*uy2 - 2.*h010*u.y + h020;
	temp110 = h000*uxuy - h010*u.x - h100*u.y + h110;
	temp210 = -h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy - 2.*h110*u.x - h200*u.y + h210;
	temp120 = -h000*u.x*uy2 + 2.*h010*uxuy - h020*u.x + h100*uy2 - 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 - 2.*h010*ux2*u.y + h020*ux2 - 2.*h100*u.x*uy2 + 4.*h110*uxuy - 2.*h120*u.x + h200*uy2 - 2.*h210*u.y + h220;
	//collision in central moments space
	//collide
	h000 = H;
	h100 = -temp100*(omega_ade - 1.);
	h010 = -temp010*(omega_ade - 1.);
	h200 = H*Sigma2;
	h020 = H*Sigma2;
	h110 = 0;
	h210 = -temp210*(omega_ade - 1.);
	h120 = -temp120*(omega_ade - 1.);
	h220 = H*Sigma2*Sigma2;

	vector_t u_new;
	u_new.x = u_hydro.x*omega_ade +u.x*(1.0-omega_ade);
	u_new.y = u_hydro.y*omega_ade +u.y*(1.0-omega_ade);

	u.x = u_new.x;
	u.y = u_new.y;
	uxuy = u.x*u.y;
	ux2 = u.x*u.x;
	uy2 = u.y*u.y;


	//back to raw moments
	temp000 = h000;
	temp100 = h000*u.x + h100;
	temp010 = h000*u.y + h010;
	temp200 = h000*ux2 + 2.*h100*u.x + h200;
	temp020 = h000*uy2 + 2.*h010*u.y + h020;
	temp110 = h000*uxuy + h010*u.x + h100*u.y + h110;
	temp210 = h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy + 2.*h110*u.x + h200*u.y + h210;
	temp120 = h000*u.x*uy2 + 2.*h010*uxuy + h020*u.x + h100*uy2 + 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 + 2.*h010*ux2*u.y + h020*ux2 + 2.*h100*u.x*uy2 + 4.*h110*uxuy + 2.*h120*u.x + h200*uy2 + 2.*h210*u.y + h220;
	//back to density-probability functions
	h000 = temp000 - temp020 - temp200 + temp220;
	h100 = 1/2.*temp100 - 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h200 = -1/2.*temp100 + 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h010 = 1/2.*temp010 + 1/2.*temp020 - 1/2.*temp210 - 1/2.*temp220;
	h110 = 1/4.*temp110 + 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h210 = -1/4.*temp110 - 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h020 = -1/2.*temp010 + 1/2.*temp020 + 1/2.*temp210 - 1/2.*temp220;
	h120 = -1/4.*temp110 + 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
	h220 = 1/4.*temp110 - 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
}

CudaDeviceFunction void relax_and_collide_ADE_CM_HIGHER_PROB_M_EQ(real_t rho, real_t omega_ade, vector_t u_hydro) 
{
	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	#ifdef OPTIONS_CHT
		real_t Sigma2 = 1./3.*h_stability_enhancement/(cp*rho);
	#else
		real_t Sigma2 = 1./3.;
	#endif

	real_t H = h000 + h010 + h020 + h100 + h110 + h120 + h200 + h210 + h220;
	real_t temp000 = h000;
	real_t temp100 = h100;
	real_t temp010 = h010;
	real_t temp200 = h200;
	real_t temp020 = h020;
	real_t temp110 = h110;
	real_t temp210 = h210;
	real_t temp120 = h120;
	real_t temp220 = h220;
	//raw moments from density-probability functions
	h000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	h010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	h200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	h110 = temp110 - temp120 - temp210 + temp220;
	h210 = temp110 - temp120 + temp210 - temp220;
	h120 = temp110 + temp120 - temp210 - temp220;
	h220 = temp110 + temp120 + temp210 + temp220;

	vector_t u;
	u.x = h100/h000;
	u.y = h010/h000;
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	//central moments from raw moments
	temp000 = h000;
	temp100 = -h000*u.x + h100;
	temp010 = -h000*u.y + h010;
	temp200 = h000*ux2 - 2.*h100*u.x + h200;
	temp020 = h000*uy2 - 2.*h010*u.y + h020;
	temp110 = h000*uxuy - h010*u.x - h100*u.y + h110;
	temp210 = -h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy - 2.*h110*u.x - h200*u.y + h210;
	temp120 = -h000*u.x*uy2 + 2.*h010*uxuy - h020*u.x + h100*uy2 - 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 - 2.*h010*ux2*u.y + h020*ux2 - 2.*h100*u.x*uy2 + 4.*h110*uxuy - 2.*h120*u.x + h200*uy2 - 2.*h210*u.y + h220;
	
	//collision in central moments space
	//collide
	vector_t du;
	du.x = u_hydro.x -u.x;
	du.y = u_hydro.y -u.y;
	real_t duxuy = du.x*du.y;
    real_t dux2 = du.x*du.x;
    real_t duy2 = du.y*du.y;

	h000 = H;
	h100 = H*du.x*omega_ade-temp100*(omega_ade - 1.);
	h010 = H*du.y*omega_ade-temp010*(omega_ade - 1.);
	h200 = H*(Sigma2 + dux2);
	h020 = H*(Sigma2 + duy2);
	h110 = H*duxuy;
	h210 = H*du.y*(dux2 + Sigma2)*omega_ade-temp210*(omega_ade - 1.);
	h120 = H*du.x*(duy2 + Sigma2)*omega_ade-temp120*(omega_ade - 1.);
	h220 = H*(dux2*duy2 + Sigma2*dux2 + Sigma2*duy2 + Sigma2*Sigma2);

	//back to raw moments
	temp000 = h000;
	temp100 = h000*u.x + h100;
	temp010 = h000*u.y + h010;
	temp200 = h000*ux2 + 2.*h100*u.x + h200;
	temp020 = h000*uy2 + 2.*h010*u.y + h020;
	temp110 = h000*uxuy + h010*u.x + h100*u.y + h110;
	temp210 = h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy + 2.*h110*u.x + h200*u.y + h210;
	temp120 = h000*u.x*uy2 + 2.*h010*uxuy + h020*u.x + h100*uy2 + 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 + 2.*h010*ux2*u.y + h020*ux2 + 2.*h100*u.x*uy2 + 4.*h110*uxuy + 2.*h120*u.x + h200*uy2 + 2.*h210*u.y + h220;
	//back to density-probability functions
	h000 = temp000 - temp020 - temp200 + temp220;
	h100 = 1/2.*temp100 - 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h200 = -1/2.*temp100 + 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h010 = 1/2.*temp010 + 1/2.*temp020 - 1/2.*temp210 - 1/2.*temp220;
	h110 = 1/4.*temp110 + 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h210 = -1/4.*temp110 - 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h020 = -1/2.*temp010 + 1/2.*temp020 + 1/2.*temp210 - 1/2.*temp220;
	h120 = -1/4.*temp110 + 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
	h220 = 1/4.*temp110 - 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
}

CudaDeviceFunction void relax_and_collide_ADE_CM_HIGHER(real_t rho, real_t omega_ade, vector_t u, vector_t fluxHDarcy) 
{


	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	#ifdef OPTIONS_CHT
		real_t Sigma2 = 1./3.*h_stability_enhancement/(cp*rho);
	#else
		real_t Sigma2 = 1./3.;
	#endif


	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;

	real_t H = h000 + h010 + h020 + h100 + h110 + h120 + h200 + h210 + h220;
	real_t temp000 = h000;
	real_t temp100 = h100;
	real_t temp010 = h010;
	real_t temp200 = h200;
	real_t temp020 = h020;
	real_t temp110 = h110;
	real_t temp210 = h210;
	real_t temp120 = h120;
	real_t temp220 = h220;

	
	//raw moments from density-probability functions
	h000 = temp000 + temp010 + temp020 + temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h100 = temp100 + temp110 + temp120 - temp200 - temp210 - temp220;
	h010 = temp010 - temp020 + temp110 - temp120 + temp210 - temp220;
	h200 = temp100 + temp110 + temp120 + temp200 + temp210 + temp220;
	h020 = temp010 + temp020 + temp110 + temp120 + temp210 + temp220;
	h110 = temp110 - temp120 - temp210 + temp220;
	h210 = temp110 - temp120 + temp210 - temp220;
	h120 = temp110 + temp120 - temp210 - temp220;
	h220 = temp110 + temp120 + temp210 + temp220;

	// h100 += fluxHDarcy.x/2.;
	// h010 += fluxHDarcy.y/2.;

	//central moments from raw moments
	temp000 = h000;
	temp100 = -h000*u.x + h100;
	temp010 = -h000*u.y + h010;
	temp200 = h000*ux2 - 2.*h100*u.x + h200;
	temp020 = h000*uy2 - 2.*h010*u.y + h020;
	temp110 = h000*uxuy - h010*u.x - h100*u.y + h110;
	temp210 = -h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy - 2.*h110*u.x - h200*u.y + h210;
	temp120 = -h000*u.x*uy2 + 2.*h010*uxuy - h020*u.x + h100*uy2 - 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 - 2.*h010*ux2*u.y + h020*ux2 - 2.*h100*u.x*uy2 + 4.*h110*uxuy - 2.*h120*u.x + h200*uy2 - 2.*h210*u.y + h220;
	//collision in central moments space
	//collide
	h000 = H;
	h100 = temp100*(1.- omega_ade);
	h010 = temp010*(1.- omega_ade);
	h200 = H*Sigma2;
	h020 = H*Sigma2;
	h110 = 0;
	h210 = temp210*(1.- omega_ade);
	h120 = temp120*(1.- omega_ade);
	h220 = H*Sigma2*Sigma2;

	// porous flavour:
	h010 += (1.- omega_ade/2.)*fluxHDarcy.y;
	h100 += (1.- omega_ade/2.)*fluxHDarcy.x;
	h210 += Sigma2*Sigma2*(1.- omega_ade/2.)*fluxHDarcy.y;
	h120 += Sigma2*Sigma2*(1.- omega_ade/2.)*fluxHDarcy.x;

	//back to raw moments
	temp000 = h000;
	temp100 = h000*u.x + h100;
	temp010 = h000*u.y + h010;
	temp200 = h000*ux2 + 2.*h100*u.x + h200;
	temp020 = h000*uy2 + 2.*h010*u.y + h020;
	temp110 = h000*uxuy + h010*u.x + h100*u.y + h110;
	temp210 = h000*ux2*u.y + h010*ux2 + 2.*h100*uxuy + 2.*h110*u.x + h200*u.y + h210;
	temp120 = h000*u.x*uy2 + 2.*h010*uxuy + h020*u.x + h100*uy2 + 2.*h110*u.y + h120;
	temp220 = h000*ux2*uy2 + 2.*h010*ux2*u.y + h020*ux2 + 2.*h100*u.x*uy2 + 4.*h110*uxuy + 2.*h120*u.x + h200*uy2 + 2.*h210*u.y + h220;
	//back to density-probability functions
	h000 = temp000 - temp020 - temp200 + temp220;
	h100 = 1/2.*temp100 - 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h200 = -1/2.*temp100 + 1/2.*temp120 + 1/2.*temp200 - 1/2.*temp220;
	h010 = 1/2.*temp010 + 1/2.*temp020 - 1/2.*temp210 - 1/2.*temp220;
	h110 = 1/4.*temp110 + 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h210 = -1/4.*temp110 - 1/4.*temp120 + 1/4.*temp210 + 1/4.*temp220;
	h020 = -1/2.*temp010 + 1/2.*temp020 + 1/2.*temp210 - 1/2.*temp220;
	h120 = -1/4.*temp110 + 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
	h220 = 1/4.*temp110 - 1/4.*temp120 - 1/4.*temp210 + 1/4.*temp220;
}

CudaDeviceFunction vector_t relax_and_collide_hydro(vector_t Force, real_t omega)
{
	//  real_t d = getRho_();
	real_t  w[4] = {omega,1.,1.,1.};  // defining relaxation rate for first cummulants

	// from density-probability function to moments 
	f000 = f200 + f100 + f000;
	f100 = -f200 + f100;
	f200 = f100 + f200*2.;
	f010 = f210 + f110 + f010;
	f110 = -f210 + f110;
	f210 = f110 + f210*2.;
	f020 = f220 + f120 + f020;
	f120 = -f220 + f120;
	f220 = f120 + f220*2.;
	f000 = f020 + f010 + f000;
	f010 = -f020 + f010;
	f020 = f010 + f020*2.;
	f100 = f120 + f110 + f100;
	f110 = -f120 + f110;
	f120 = f110 + f120*2.;
	f200 = f220 + f210 + f200;
	f210 = -f220 + f210;
	f220 = f210 + f220*2.;
	// from moments to cumulants
	real_t c000 = f000;
	real_t c100 = f100/f000;
	real_t c200 = ( -c100*f100 + f200 )/f000;
	real_t c010 = f010/f000;
	real_t c110 = ( -c100*f010 + f110 )/f000;
	real_t c210 = ( -c110*f100 - c200*f010 - c100*f110 + f210 )/f000;
	real_t c020 = ( -c010*f010 + f020 )/f000;
	real_t c120 = ( -c100*f020 + f120 - c110*f010*2. )/f000;
	real_t c220 = ( -c120*f100 - c200*f020 - c100*f120 + f220 + ( -c210*f010 - c110*f110 )*2. )/f000;
	// Getting the velocity from the cummulants and force term
	vector_t u;
	u.x = c100 + Force.x/(2.*c000);
	u.y = c010 + Force.y/(2.*c000);
	u.z = 0;

	real_t kin_visc = (1./omega - 0.5)/3.;

	real_t permability = getPermability(Kazeny_NScoeff);
	vector_t ForceD = getDarcyForce(u, c000, kin_visc, permability);

	u.x += ForceD.x/(2.*c000);
	u.y += ForceD.y/(2.*c000);

	//Cumulant relaxation:
	real_t  a = (c200 + c020);
	real_t  b = (c200 - c020);
	//Forcing - Exact Difference Method by Kupershtokh, 2009
	c100 = c100 + Force.x + ForceD.x;
	c010 = c010 + Force.y + ForceD.y;
	//END Forcing
	//real_t Dxu = - w[0]*(2*c200 - c020)/(2.*d) - w[1]*(c200 + c020)/d;
	//real_t Dyv =  - w[0]*(2*c020 - c200)/(2.*d) - w[1]*(c200 + c020)/d;
	// c100 = -c100;
	// c200 = (1 - w[0])*c200 + w[0]*1./3;
	c200 = ((1 - w[1])*a + w[1]*2./3. + (1 - w[0])*b)/2.;
	// c010 =-c010;
	// c020 = (1 - w[0])*c020 + w[0]*1./3;

	c020 = ((1 - w[1])*a + w[1]*2./3. - (1 - w[0])*b)/2.;
	c110 = (1- w[0])*c110;

	c210 = (1 - w[2])*c210;
	c120 = (1 - w[2])*c120;
	c220 = (1 - w[3])*c220;

	// from cummulants to moments
	f000 = f000;
	f100 = c100*f000;
	f200 = c200*f000 + c100*f100;
	f010 = c010*f000;
	f110 = c110*f000 + c100*f010;
	f210 = c210*f000 + c110*f100 + c200*f010 + c100*f110;
	f020 = c020*f000 + c010*f010;
	f120 = c120*f000 + c100*f020 + c110*f010*2.;
	f220 = c220*f000 + c120*f100 + c200*f020 + c100*f120 + ( c210*f010 + c110*f110 )*2.;

	// from moments to density-probability function
	f000 = -f200 + f000;
	f100 = ( f200 + f100 )/2.;
	f200 = f200 - f100;
	f010 = -f210 + f010;
	f110 = ( f210 + f110 )/2.;
	f210 = f210 - f110;
	f020 = -f220 + f020;
	f120 = ( f220 + f120 )/2.;
	f220 = f220 - f120;
	f000 = -f020 + f000;
	f010 = ( f020 + f010 )/2.;
	f020 = f020 - f010;
	f100 = -f120 + f100;
	f110 = ( f120 + f110 )/2.;
	f120 = f120 - f110;
	f200 = -f220 + f200;
	f210 = ( f220 + f210 )/2.;
	f220 = f220 - f210;
	
	return u;
}


<?RT models/porous_media/d2q9_porous_heat/ForcingTerms.c.Rt ?>

CudaDeviceFunction real_t GetOmegaTRTPlus(real_t diff_coeff, real_t permability)
{	
	// the diff_coeff referers either to viscosity (NS) or conductivity (ADE)
	// without porous effect, one would write real_t omega_k = 1.0/(3*conductivity+0.5);

	// TRT flavour adopted from MD's auto_porous_media model inspired by

	// I. Ginzburg, G. Silva, L. Talon, 
	// Analysis and improvement of brinkman lattice boltzmann schemes: Bulk, boundary, interface. 
	// Similarity and distinctness with finite elements in heterogeneous porous media, Phys. Rev. E 91 (2015) 023307.
	// real_t conductivity = (1./omega_ade-0.5)/3.;
	real_t Magic = 3./16;
	const real_t Lambda = Magic;
	const real_t B = 1. / permability;
	const real_t LambdaPlus = 9. * (4. + B) / ( 4. *( 3.+2.*B*Lambda ) ) * diff_coeff;
	const real_t LambdaMinus = Lambda / 3. /  diff_coeff;

	// USAGE

	// NS
	// const real_t omega_sym = 1./(  LambdaPlus + 0.5 ); //symmetric relaxation
	// const real_t omega_antysym = 1./(  LambdaMinus + 0.5 ); //non-symmetric relaxation
	/// end of MD snippet

	// ADE
	// const real_t omega_sym = 1./( LambdaMinus  + 0.5 ); //symmetric relaxation
	// const real_t omega_antysym = 1./(  LambdaPlus + 0.5 ); //non-symmetric relaxation

	return 1./(  LambdaPlus + 0.5 );
}

CudaDeviceFunction vector_t hydro_collision_wrapper(real_t rho)
{
	real_t localTemperature = getT_();
	vector_t ForceB = getBoussinesqForce(localTemperature, rho);

	// real_t omega_nu = 1.0/(3*nu+0.5);

	real_t permability = getPermability(Kazeny_NScoeff);
	real_t omega_nu = GetOmegaTRTPlus(nu, permability);
	if ((NodeType & NODE_BOUNDARY) != 0) omega_nu = 1.0/(3*nu_buffer+0.5);
	vector_t u = relax_and_collide_hydro(ForceB, omega_nu);

	return u;
}

CudaDeviceFunction void CollisionCM_HIGHER(){
	real_t rho = getRho_();
	vector_t u = hydro_collision_wrapper(rho);

	// porous flavour:
	vector_t Hflux = getHflux();  // rho u T + Q^neq
	real_t permability = getPermability(Kazeny_Hcoeff);
	real_t omega_k = GetOmegaTRTPlus(conductivity, permability);
	// real_t omega_k = 1.0/(3*conductivity/rho +0.5);
	real_t conductivity_with_poro = (1./omega_k - 0.5)/3.;
	vector_t fluxHDarcy = getHDarcyForce(Hflux, conductivity_with_poro, permability);
	// fluxHDarcy.x = 0;
	// fluxHDarcy.y = 0;

	if ((NodeType & NODE_BOUNDARY) != 0) omega_k = 1.0/(3*conductivity_buffer+0.5);
	relax_and_collide_ADE_CM_HIGHER(rho, omega_k, u, fluxHDarcy);
}

CudaDeviceFunction void CollisionCM_HIGHER_PROB(){
	real_t rho = getRho_();
	vector_t u = hydro_collision_wrapper(rho);
	real_t omega_k = 1.0/(3*conductivity+0.5);
	if ((NodeType & NODE_BOUNDARY) != 0) omega_k = 1.0/(3*conductivity_buffer+0.5);
	relax_and_collide_ADE_CM_HIGHER_PROB(rho, omega_k, u);
}

CudaDeviceFunction void CollisionCM_HIGHER_PROB_M_EQ(){
	real_t rho = getRho_();
	vector_t u = hydro_collision_wrapper(rho);
	real_t omega_k = 1.0/(3*conductivity+0.5);
	if ((NodeType & NODE_BOUNDARY) != 0) omega_k = 1.0/(3*conductivity_buffer+0.5);
	relax_and_collide_ADE_CM_HIGHER_PROB_M_EQ(rho, omega_k, u);
}

CudaDeviceFunction void CollisionCumulants(){
	real_t rho = getRho_();
	vector_t u = hydro_collision_wrapper(rho);

	real_t permability = getPermability(Kazeny_Hcoeff);
	real_t omega_k = GetOmegaTRTPlus(conductivity, permability);
	real_t conductivity_with_poro = (1./omega_k - 0.5)/3.;

	vector_t Hflux = getHflux();
	real_t H =  getH();
	Hflux.x /= H;
	Hflux.y /= H;
	vector_t fluxHDarcy = getHDarcyForce(Hflux, conductivity_with_poro, permability);

	// real_t omega_k = 1.0/(3*conductivity+0.5);
	if ((NodeType & NODE_BOUNDARY) != 0) omega_k = 1.0/(3*conductivity_buffer+0.5);
	relax_and_collide_ADE_Cumulants(rho, omega_k, u, fluxHDarcy);
}

